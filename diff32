# -*-Awk-*-
#!/bin/sh

########################### diff32 bash paging wrapper ##########################
# Implements process/pipe/signal handling for use of a default pager with the
# diff32 gawk script. gawk doesn't offer any signal handling, thus this wrapper.
#
# We want ^C (SIGINT) to interrupt any in-progress/runaway computation but also
# cleanly exit a pager.  The pager must exit first, else the terminal gets
# clobbered by out-of-order cleanup.
#
# The wrapper also makes sure ^C really shuts down everything. If gawk gets hung
# in a loop or due to a bug, it won't notice that stdout/stderr simply went away.
# After the pager exits, the interrupt handler issues a kill 0.
#################### bash script continues after gawk section ###################

exec {script_fd}<<'#EOF'

############################### diff32 gawk script ##############################
#!/usr/bin/gawk -E   # Unnecessary, seems clearer to include it.

#---------------------------------------------------------------------
#            POSIX CRC32 implementation.  Self-contained, no side
#            effects outside this layer.  init() creates a global
#            crc_table[] lookup.
#
#            The values calculated and printed are compatible with GNU
#            cksum, which includes byte count in the calculation.
#            Calculation is byte-reversed (not bitreversed) from the
#            usual inplementations, so the printed results must bre
#            byteswapped before printing.

# input: single numeric byte, integer crc state
function crc32_byte(v, crc) {
    return xor(rshift(crc, 8), crc_table[and(xor(crc,v),0xff)])
}

# Initialize the crc lookup table.
function init_crc(                              \
                  i, j, a, b, c, d){
    for(i=0;i<256;i++){
        a = i
        b = 0
        c = 0
        d = 0
        for(j=0;j<8;j++){
            a = lshift(a,1)
            b = lshift(b,1)
            c = lshift(c,1)
            d = lshift(d,1)
            if(!and(a,0x100))continue
            a = xor(a,0x04)
            b = xor(b,0xC1)
            c = xor(c,0x1D)
            d = xor(d,0xB7)
        }
        a = and(xor(a,rshift(b,8)),0xff)
        b = and(xor(b,rshift(c,8)),0xff)
        c = and(xor(c,rshift(d,8)),0xff)
        d = and(                 d,0xff)
        crc_table[i] = lshift(d,24)+lshift(c,16)+lshift(b,8)+a
    }
}

# byteswap for printing CRC32 values that match cksum.
function byteswap4(v,
                   i, r){
    for(i=0;i<4;i++){
        r = lshift(r,8)
        r = r + and(v,0xff)
        v = rshift(v,8)
    }
    return r
}

# add a byte length to a naked checksum, complement, and bytereverse
# for printing cksum compatible results.
function gnuify_crc32(crc, bytelength){
    while(bytelength){
        crc = crc32_byte(and(bytelength,0xff),crc)
        bytelength = rshift(bytelength,8)
    }
    return byteswap4(and(compl(crc),0xffffffff))
}

#---------------------------------------------------------------------
#            Basic tty capability querying and attribute usage layer
#            using ANSI sgr escape codes.  Used to pretty-print output
#            on the terminal.  It determines the console's formatting
#            capability, generates escape strings and tracks attributes
#            currently set.
#
#            Side-effects are all self-contained, globals in the tty_
#            and TTY_ namespaces.  The TTY layer is used by the line
#            buffering and color layers that follow.

# Helper string function to extract a relevant simple escape code from
# a terminfo entry.
function _tkey(source, key,
                       ret){
    match(source, key"=\\\\E\\[([0-9]+)", ret)
    return ret[1]
}

# Very simple tty escape code capability query using infocmp(1).
# Determines what formatting capabilities are supported, markes
# terminal formatting active.
function fetch_tty_capability() {
    # fetch terminal info if we can
    if(INFOCMP){
        RS="^$"
        if ((cmd = INFOCMP" -a -0") | getline) {
            term = $0
            close(cmd)
        }
        RS="\n"
    }
    # Global cattribute bitflags
    TTY_BOLD       = lshift(1,8)
    TTY_DIM        = lshift(2,8)
    TTY_ITALIC     = lshift(4,8)
    TTY_UNDERLINE  = lshift(8,8)
    TTY_INVERSE    = lshift(16,8)
    TTY_INVISIBLE  = lshift(32,8)
    TTY_STRIKEOUT  = lshift(64,8)
    TTY_COLOR      = 255
    TTY_NOCOLOR    = 0
    TTY_RED        = 31
    TTY_GREEN      = 32
    if (term ~ /colors/) {
        tty_active = 1
        # extract codes that set attributes
        tty_set_code[TTY_COLOR] = "xx" # hack; replaced on demand later
        tty_set_code[TTY_BOLD] = _tkey(term,"bold")
        tty_set_code[TTY_DIM] = _tkey(term,"dim")
        tty_set_code[TTY_ITALIC] = _tkey(term,"sitm")
        tty_set_code[TTY_UNDERLINE] = _tkey(term, "smul")
        tty_set_code[TTY_INVERSE] = _tkey(term,"rev")
        tty_set_code[TTY_INVISIBLE] = _tkey(term, "invis")
        if (!(term ~ /eo=/))
            tty_set_code[TTY_STRIKEOUT] = _tkey(term,"smxx")
        # extract codes that reset attributes
        tty_reset_code[TTY_COLOR] = _tkey(term,"op")
        tty_reset_code[TTY_ITALIC] = _tkey(term, "ritm")
        tty_reset_code[TTY_UNDERLINE] = _tkey("rmul")
        if (tty_set_code[TTY_INVERSE] == _tkey(term, "smso"))
            tty_reset_code[TTY_INVERSE] = _tkey(term, "rmso")
        if (!(term ~ /eo=/))
            tty_reset_code[TTY_STRIKEOUT] = _tkey(term,"rmxx")
        # what set codes do not have corresponding resets (eg,
        # attributes that require a full attribute reset)?
        for(attr in tty_set_code){
            if(tty_set_code[attr] && !tty_reset_code[attr]){
                # Add to list of attributes with no specific reset.
                TTY_RESETS = or(TTY_RESETS, attr)
            }else if (!tty_set_code[attr]){
                # A reset with no set?  Remove it.
                tty_reset_code[attr]=""
            }
        }
    }
}

# Clears terminal formatting capabilities, marks terminal formatting
# inactive.
function clear_tty_capability(){
    tty_active = 0
    delete tty_set_code
    delete tty_reset_code
    TTY_RESETS = 0
}

# Determine if the passed in formatting attributes are all supported
# by the terminal.  Takes an or-ed set of TTY_ attribute bitflags.
function tty_q(attrs){
    for(attr in tty_set_code){
        if(and(attrs,attr) && !tty_set_code[attr]) return 0
    }
    return 1
}

# Generates and escape sequence to set the terminal to the requested
# attribute state based on capability and current state, sets current
# state to request.  Takes a set of or-ed TTY_ attribute bitflags
# reflecting desired state.  Safe to call when terminal is inactive
# (no-op).
function tty_set(attrs,
                 ret){
    if(tty_active){
        # resetting to default is straightforward
        if(attrs != tty_current_attributes) {
            ret = "\033["
            if(attrs == 0) {
                ret = ret"m"
            } else {
                # hack to set color by code
                tty_set_code[TTY_COLOR] = ""and(attrs,TTY_COLOR)
                # can we modify the current attribute set without a full reset?
                if(and(attrs,and(tty_current_attributes, TTY_RESETS)) != \
                   and(tty_current_attributes, TTY_RESETS)){
                    # no.  Issue reset, then further escapes.
                    ret = ret"0;"
                    tty_current_attributes = 0
                }
                # handle attributes
                for(key in tty_set_code){
                    if(and(attrs, key) != and(tty_current_attributes, key)){
                        if(and(attrs, key)){
                            if(tty_set_code[key]) ret = ret""tty_set_code[key]";"
                        } else {
                            if(tty_reset_code[key]) ret=ret""tty_reset_code[key]";"
                        }
                    }
                }
                # remove last semicolon
                gsub(/;$/,"",ret)
                ret = ret"m"
            }
            tty_current_attributes = attrs
        }
    }
    return ret
}

#---------------------------------------------------------------------
#            Line-buffered data output layer.  No side effects outside
#            this layer, though it access variables from the terminal
#            setup layer.
#
#            Global state: output_q_buffer
#                          output_q_lineready
#                          current_q_attribute
#
#            The line buffer layer queues pieces of a line (or lines
#            really) to be explicitly flushed.  The goal here is not
#            performance, but a hack to allow us to go back and alter
#            the pretty-printing on block boundaries (specifically a
#            block end/footer) without having to work ahead by
#            arbitrary amount, or store additional structuredprinting
#            state.  It also tracks the last set ANSI attribute string
#            set by pretty-printing and does not re-emit if the same
#            setting is requested again.

# Accepts a string fragment to add to the queue. Optional argument
# sets the passed ANSI escape attributes if not already set to the
# same flag set.  Omitting the optional argument emits the sequence to
# disable the currently set attributes.
function q(string, attrs){
    if (output_q_lineready) q_flush()
    output_q_buffer = output_q_buffer""tty_set(attrs)""string
}

# Retroactively underlines the text present in the line buffer,
# assuming terminal supports the underline operation. This is a dirty
# layer-violating hack that avoids some amount of more complex
# structured buffer management in higher layers.
function q_underline(){
    if(color_address_underline){
        # 1) Explicit inline zero reset code; insert underline after it.
        output_q_buffer = gensub(/(\033\[;*([^0;m];*|[^m;]{2..};*)*)0([;m])+/,
                                 "\\10;"tty_set_code[TTY_UNDERLINE]"\\3",
                                 "g",output_q_buffer)
        # 2) Implicit reset code; replace with explicit reset +
        # underline.
        gsub(/\033\[m/,"\033[0;"tty_set_code[TTY_UNDERLINE]"m",
             output_q_buffer)
        # 3) Escape sequence at beginning of buffer or line with no
        # underline.
        output_q_buffer = gensub("(^|\\n)(\\033\\[;*([^"        \
                                 tty_set_code[TTY_UNDERLINE]    \
                                 ";m];*|[^m;]{2..};*)*)m",
                                 "\\1\\2;"tty_set_code[TTY_UNDERLINE]"m",
                                 "g",output_q_buffer)
        # 4) No sequence at beginning of buffer or line.  Add an
        # underline code.
        output_q_buffer = gensub(/(^|\n)([^\033])/,
                                 "\\1\033["tty_set_code[TTY_UNDERLINE]"m\\2",
                                 "g",output_q_buffer)
    }
}

function q_line(){
    if (output_q_lineready) q_flush()
    # set all attributes off; make the pager happy.
    output_q_buffer = output_q_buffer""tty_set(0)"\n"
    output_q_lineready = 1
}

function q_flush(){
    printf output_q_buffer
    output_q_lineready = 0
    output_q_buffer = ""
}

# Program error output
function err(string){
    print string > err_device
}

#-------------------------------------------------------------------


# Takes a string of bytes formatted as space-separated hex doubles.
# updates the cursors and performs crc if active.
function bytecount_old_word(old_word,
                            i, n, hex) {
    n = split(old_word, hex, " ")
    old_cursor += n
    if(crc_active){
        for (i=1;i<=n;i++) {
            old_crc = crc32_byte(strtonum("0x"hex[i]),old_crc)
        }
    }
}

# Takes a string of bytes formatted as space-separated hex doubles.
# updates the cursors and performs crc if active.
function bytecount_new_word(new_word,
                            i, n, hex) {
    n = split(new_word, hex, " ")
    new_cursor += n
    if(crc_active){
        for (i=1;i<=n;i++) {
            new_crc = crc32_byte(strtonum("0x"hex[i]),new_crc)
        }
    }
}

# helper function to print the input, optionally colorizing the
# nibbles that match the comparison input to_compare using the escape
# sequence 'off', and the nibbles that do not match with 'on'.  'lock'
# is nonzero if a color change to 'on' should persist for the rest of
# the string regardless of match; this is used to highlight address
# differences.
function out_highlight(to_print, to_compare, off, on, lock,
                       current, a, b, c, i){
    if (to_print == " ") {
        to_print = "            "
    }
    c=off
    for(i=1; i<=length(to_print); i++){
        a = substr(to_print,i,1)
        b = substr(to_compare,i,1)
        if(a != " "){
            if (a != b){
                c = on
            } else {
                if (!lock) c = off
            }
        }
        q(a,c)
    }
}

# Run an absolute address offset from beginning-of-file through
# the user-supplied maps to arrive at a display address.
function map_an_address(addr,
                        i){
    for (i=0; i<address_maps; i++) {
        if (address_map_src[i] <= addr) {
            addr = address_map_dst[i] + addr - address_map_src[i]
            break
        }
    }
    return addr
}

# Print an address footer at the end of a preceding block of differences.
function print_address_footer(                                  \
                              old, new, old_str, new_str){

    # Don't print a footer if there's no preceding block.
    if (hunks){
        # print crc for footer if active
        if(crc_active){
            # crc
            q(sprintf(" 0x%08x  crc  0x%08x ",
                      gnuify_crc32(block_old_crc,block_old_cursor),
                      gnuify_crc32(block_new_crc,block_new_cursor)),
              color_crc_base)
            q_line()
        }
        # Pretty-print for terminals; add an underline to the last
        # word entry.
        q_underline()
        # Print current addresses for footer.
        old_str = sprintf("0x%08x",block_old_cursor)
        new_str = sprintf("0x%08x",block_new_cursor)
        out_highlight(" "old_str," "new_str,color_address_base,
                      color_address_diff,1);
        q(" ----- ",color_address_bar)
        out_highlight(new_str" ",old_str" ",color_address_base,
                      color_address_diff,1);
        q_line()
        # blank line
        q_line()
    }
    hunks++
}

# Print an address header at the beginning of a new block of differences.
function print_address(                                                 \
                       old, new, old_str, new_str, old_map, new_map){
    old_str = sprintf("0x%08x",old_cursor)
    new_str = sprintf("0x%08x",new_cursor)
    out_highlight(" "old_str," "new_str,color_address_base,
                  color_address_diff,1);
    q(" ----- ",color_address_bar)
    out_highlight(new_str" ",old_str" ",color_address_base,
                  color_address_diff,1);
    q_underline()
    q_line()
    # If there's an address mapping in effect for this region, indicate it.
    old_map = map_an_address(old_cursor)
    new_map = map_an_address(new_cursor)
    if (old_cursor != old_map || new_cursor != new_map){
        old_str = sprintf("0x%08x",old_map)
        new_str = sprintf("0x%08x",new_map)

        out_highlight(" "old_str," "new_str,color_map_base,
                      color_map_diff,1);
        q("  map  ", color_map_base)
        out_highlight(new_str" ",old_str" ",color_map_base,
                      color_map_diff,1);
        q_line()
    }
}

# Print one line of a diff block.  Takes two words formatted for
# display, compares and applies highlights, adds the status
# indicator ('<' and/or '>') and prints.  Optionally adds dittomarks
# to clarify long runs of identical word values, but only in changed lines.
function print_diff_line(old_word, new_word,
                     c, ccolor) {
    if(old_word == new_word){
        q(sprintf(" %s     %s ", old_word, new_word), color_block_match)
        q_line()
    } else {
        if(ditto_active && old_ditto && old_ditto == old_word){
            out_highlight("     \" \"    "," "new_word,
                          color_block_oldlight,color_block_oldlight)
        }else{
            out_highlight(" "old_word," "new_word,
                          color_block_base,color_block_oldlight)
        }
        c = "  !  "
        ccolor = color_block_banglight
        if (old_word == "") {
            ccolor = color_block_newlight
            c = "  >  "
        }
        if (new_word == ""){
            ccolor = color_block_oldlight
            c = "  <  "
        }
        q(c,ccolor)
        if(ditto_active && new_ditto && new_ditto == new_word){
            out_highlight("    \" \"     ",old_word" ",
                          color_block_newlight,color_block_newlight);
        }else{
            out_highlight(new_word" ",old_word" ",
                          color_block_base,color_block_newlight);
        }
        q_line()
    }
    bytecount_old_word(old_word)
    bytecount_new_word(new_word)
    old_ditto = old_word
    new_ditto = new_word
    block_old_cursor = old_cursor
    block_new_cursor = new_cursor
    block_old_crc = old_crc
    block_new_crc = new_crc
}

function print_precontext(){
    while(context_count>0){
        context_count--
        print_diff_line(context_word[context_count],context_word[context_count])
    }
}



# Discard but count metrics for one line of a diff block; called for
# lines between blocks.  Takes two words formatted for display.
function discard_context_line(){
    if(context_count>0){
        context_count--
        bytecount_old_word(context_word[context_count])
        bytecount_new_word(context_word[context_count])
        old_ditto = ""
        new_ditto = ""
        new_block=1
    }
}

function discard_all_context(){
    # discard but count any pending pre-context
    while(context_count>0) discard_context_line()
}

function print_end(){
    print_address_footer()
    discard_all_context()
    if(block_old_cursor != old_cursor ||
       block_new_cursor != new_cursor){
        print_address()
        if(crc_active){
            q(sprintf(" 0x%08x  crc  0x%08x ",
                      gnuify_crc32(old_crc, old_cursor),
                      gnuify_crc32(new_crc, new_cursor)),
              color_crc_base)
            q_underline()
            q_line()
        }
    }
    q(" ",color_address_base)
    q("-----------",color_address_midbar)
    q(" END ",color_address_base)
    q("-----------",color_address_midbar)
    q(" ",color_address_base)
    q_line()
    q_line()
    q_flush()
}

function print_new_block(\
                         i){
    # Do we need to print an address header?
    if (new_block) {
        # Print footer for preceding block.
        print_address_footer()
        print_address()
        new_block=0
    }
    # Print any pending pre-context
    print_precontext()
    # Mark need for trailing context before starting a new address block
    context_count= -context
}

# Takes a line of input in the original packed/overlapping input
# formatting, and returns a 4-byte word formatted for printing.
function format_word(line){
    if(line == ""){
        return line
    } else {
        return sprintf("%2s %2s %2s %2s",
                       substr(line,2,2),
                       substr(line,4,2),
                       substr(line,6,2),
                       substr(line,8,2))
    }
}

function right_justify(str, chars,
                      fill){
    for(fill = chars - length(str);fill>0;fill--)
        str = " "str
    return str
}

function left_justify(str, chars,
                       fill){
    for(fill = chars - length(str);fill>0;fill--)
        str = str" "
    return str
}

# Toplevel for line-by-line output handling; manages context, address
# output, crcs, and line formatting.
function submit_line(old_line, new_line,
                     i, old_word, new_word){
    old_word = format_word(old_line)
    new_word = format_word(new_line)
    if(old_word == new_word){
        # push the line into context or print it?
        if(context_count<0){
            # running out post-context, so print
            print_diff_line(old_word,new_word)
            context_count++
        } else {
            # already passed [context] identical lines, push to context queue
            for(i=context_count;i>0;i--) {
                context_word[i]=context_word[i-1]
            }
            context_word[0] = old_word
            context_count++
            if(context_count > context) {
                # Over limit; push a line out of the context
                discard_context_line()
            }
        }
    } else {
        # conditionally start a new block output
        print_new_block()
        # Flush/print requested words as needed
        print_diff_line(old_word, new_word)
    }
}

# Specialized version of submit_line + print_diff_line for redacted
# output.
function redact_lines(num_lines,
                      i){
    if(num_lines > 0){
        # conditionally start a new block output
        print_new_block()
        # output redaction
        q(" .. .. .. .. <<< ",color_block_oldlight)
        if(num_lines==1){
            q(left_justify("1 line",12))
        }else{
            q(left_justify(sprintf("%d lines", num_lines),12))
        }
        q_line()
        # update CRC and printed byte count, must be done after
        # print_new_block()
        for(i = 0; i < num_lines; i++)
            bytecount_old_word(format_word(old_line[i]))
        block_old_cursor = old_cursor
        block_old_crc = old_crc
    }
}

# Specialized version of submit_line + print_diff_line for elided
# output.
function elide_lines(line, num_lines, old_or_new,
                       i){
    if(num_lines > 0){
        word = format_word(line)
        # conditionally start a new block output
        print_new_block()
        # output elided section
        if(old_or_new == "old"){
            out_highlight(" "word," ",color_block_base,color_block_oldlight)
            q(" <<< ",color_block_oldlight)
            if(num_lines==1){
                q(left_justify("1 line",12))
            }else{
                q(left_justify(sprintf("%d lines", num_lines),12))
            }
            # update CRC and counts, must be done after print_new_block()
            for(i = 0; i < num_lines; i++)
                bytecount_old_word(word)
        } else {
            if(num_lines==1){
                q(right_justify("1 line",12))
            }else{
                q(right_justify(sprintf("%d lines", num_lines),12))
            }
            q(" >>> ",color_block_newlight)
            out_highlight(word" "," ",color_block_base,color_block_newlight)
            # update CRC and printed byte count, must be done after
            # print_new_block()
            for(i = 0; i < num_lines; i++)
                bytecount_new_word(word)
        }
        q_line()
        block_old_cursor = old_cursor
        block_new_cursor = new_cursor
        block_old_crc = old_crc
        block_new_crc = new_crc
    }
}

# simple abs() function as there's no relaibly available built-in
function abs(v){
    if(v<0)v= -v
    return v
}

function push_old_line(line){
    old_line[old_count++]=line
    old_advance--
}

function push_new_line(line){
    new_line[new_count++]=line
    new_advance--
}

function remove_old_lines(num,
                          j){
    # More concerned about being correct than
    # efficient right now, so doing it the simple way and just
    # shifting the line buffers.
    old_count -= num
    for(j=0; j<old_count; j++) old_line[j]=old_line[j+num]
}

function remove_new_lines(num,
                      j){
    # More concerned about being correct than
    # efficient right now, so doing it the simple way and just
    # shifting the line buffers.
    new_count -= num
    for(j=0; j<new_count; j++) new_line[j]=new_line[j+num]
}

# Given a subsection, determine if repeated lines need should be
# elided for clarity.  Elide only if pure insertion, deletion, or both
# sides of the diff are repeats.  Ditto marking is handled elsewhere.
function elide_split(old_end, new_end,
                        i, j, old_pos, new_pos){
    old_pos=0
    new_pos=0
    while(old_pos < old_end || new_pos < new_end){
        # match lines are never elided; they're likely to be
        # part of context.
        if(old_pos < old_end && new_pos < new_end &&
           substr(old_line[old_pos],2,8) == substr(new_line[new_pos],2,8)){
            submit_line(old_line[old_pos], new_line[new_pos])
            old_pos++
            new_pos++
        } else {
            for(i=old_pos+1; i<old_end; i++){
                if(substr(old_line[old_pos],2,8) != substr(old_line[i],2,8)) break
            }
            for(j=new_pos+1; j<new_end; j++){
                if(substr(new_line[new_pos],2,8) != substr(new_line[j],2,8)) break
            }
            i-=old_pos
            j-=new_pos
            if(i>elision_thresh && j>elision_thresh){
                # both sides have sufficient repeats to bother eliding.
                elide_lines(old_line[old_pos],i,"old")
                elide_lines(new_line[new_pos],j,"new")
                old_pos+=i
                new_pos+=j
                continue
            }
            # Only elide as much as would shorten output
            if(i>old_end-old_pos-new_end+new_pos){
                i = old_end-old_pos-new_end+new_pos
            }
            if(j>new_end-new_pos-old_end+old_pos){
                j = new_end-new_pos-old_end+old_pos
            }
            if(i>elision_thresh){
                # deletion
                elide_lines(old_line[old_pos],i,"old")
                old_pos+=i
                continue
            }
            if(j>elision_thresh){
                # insertion
                elide_lines(new_line[new_pos],j,"new")
                new_pos+=j
                continue
            }
            if(old_pos<old_end && new_pos<new_end){
                submit_line(old_line[old_pos], new_line[new_pos])
                old_pos++
                new_pos++
                continue
            }
            if(old_pos<old_end){
                submit_line(old_line[old_pos],"")
                old_pos++
                continue
            }
            submit_line("",new_line[new_pos])
            new_pos++
        }
    }
}

function output_split(old_end, new_end,
                     i, j, old_pos, new_pos){
    # search exact word match up from bottom
    old_pos=old_end
    new_pos=new_end
    while(old_pos>0 && new_pos>0){
        if(substr(old_line[old_pos-1],2,8)!=            \
           substr(new_line[new_pos-1],2,8))break;
        old_pos--
        new_pos--
    }

    # When redacting input, we only worry about the mid lines of the
    # split.  Initial leading exact matches are stripped away by
    # forward match.  We shouldn't have any trailing exact matches at
    # the bottom of the split, because context is normally 0.  If
    # context is not 0 then that's a user override, so don't redact it.
    if (redact_active) {
        redact_lines(old_pos)
        if(elision_active){
            elide_split(0,new_pos)
        }else{
            for(j=0; j<new_pos; j++)
                submit_line("",new_line[j])
        }
    } else {
        if(elision_active){
            elide_split(old_pos,new_pos)
        }else{
            for(i=0; i<old_pos && i<new_pos; i++)
                submit_line(old_line[i], new_line[i])
            for(j=i; j<old_pos; j++)
                submit_line(old_line[j],"")
            for(j=i; j<new_pos; j++)
                submit_line("",new_line[j])
        }
    }

    # now push the exact bottom matches; don't redact or elide.
    while(old_pos<old_end && new_pos<new_end){
        submit_line(old_line[old_pos], new_line[new_pos])
        old_pos++
        new_pos++
    }
    # done
    remove_old_lines(old_end)
    remove_new_lines(new_end)
}

function match_forward(old_end, new_end,
                       i){
    # Excluding words from the initial exact natching through diff
    # will result in diff sections that begin with or consist
    # entirely of lines that actually do match.  Start by
    # submitting these exact matches (which will handle any
    # outputting needed).  Similarly, the recursive parsing breaks
    # up regions by exact match, and those exact matches will need
    # to be pushed out here as well.
    for(i=0; i<old_end && i<new_end; i++){
        if(substr(old_line[i],2,8) != substr(new_line[i],2,8))break
        submit_line(old_line[i],new_line[i])
    }

    # Submitted lines need to be removed from the old and
    # new line lists.
    remove_old_lines(i)
    remove_new_lines(i)
    return i
}

function match_search(old_end, new_end, pos_return,
                      i, j){
    # search by increasing offset
    for (j=0; j<old_end || j<new_end; j++) {
        # common overlap loop
        for(i=0; i<new_end-j && i<old_end-j; i++){
            if(old_line[i] == new_line[i+j]) {
                pos_return["old"] = i
                pos_return["new"] = i+j
                pos_return["off"] = -j
                return
            }
            if(old_line[i+j] == new_line[i]) {
                pos_return["old"] = i+j
                pos_return["new"] = i
                pos_return["off"] = j
                return
            }
        }
        # more negative offset to search?
        while(i<new_end-j && i<old_end){
            if(old_line[i] == new_line[i+j]){
                pos_return["old"] = i
                pos_return["new"] = i+j
                pos_return["off"] = -j
                return
            }
            i++
        }
        # more positive offset to search?
        while(i<old_end-j && i<new_end){
            if(old_line[i+j] == new_line[i]){
                pos_return["old"] = i+j
                pos_return["new"] = i
                pos_return["off"] = j
                return
            }
            i++
        }
    }
    pos_return["old"] = old_end
    pos_return["new"] = new_end
    pos_return["off"] = old_end - new_end
}

function trim_for_subsearch(old_end, new_end, len,
                                   i){
    for(i=0; i<old_end; i++) old_line[i] = substr(old_line[i],1,len)
    for(i=0; i<new_end; i++) new_line[i] = substr(new_line[i],1,len)
}

function set_exclusions(old_end,
                        i){
    for(i=0; i<old_end; i++)
        old_line[i]=gensub(/(w)(00000000|ffffffff)/,"x\\2","g",old_line[i])
}

function clear_exclusions(old_end,
                          i){
    for(i=0; i<old_end; i++) gsub(/x/,"w",old_line[i])
}

function weak_split(old_end, new_end, threshold,
                    i, j, pos){
    if(threshold < match_words_min){
        clear_exclusions(old_end)
        output_split(old_end, new_end)
    }else{
        # Rather than complicating match with substr, perform it up front.
        trim_for_subsearch(old_end, new_end, threshold*9)

        while (new_end>0 || old_end>0) {
            i = match_forward(old_end, new_end)
            # update our own local subset end count
            old_end -= i
            new_end -= i
            # Do nothing further if that was the whole section.
            if(old_end==0 && new_end==0) break;

            # Look forward for exact matches; we split diff parsing at
            # that point.
            match_search(old_end, new_end, pos)

            # recurse, match or no.
            weak_split(pos["old"], pos["new"], threshold-1)

            # The weak_split call will always consume the entire region
            # passed to it.
            old_end -= pos["old"]
            new_end -= pos["new"]
        }
    }
}

# Successively break up initial region into exact matches searched by
# increasing offset.
function strong_split(old_end, new_end,
                      i, j, pos){
    while (new_end>0 || old_end>0) {
        i = match_forward(old_end, new_end)
        # update our own local subset end count
        old_end -= i
        new_end -= i
        # Do nothing further if that was the whole section.
        if(old_end==0 && new_end==0) break

        # Look forward for exact matches; we split diff parsing at
        # that point.
        match_search(old_end, new_end, pos)

        # If no exact matches, our region is not bookmarked by
        # initial matches, and so we don't have enough information
        # to make a good submatch.  Return.
        if(pos["old"] == old_end) break

        # if no currently active match horizon point, set it
        if(!advance_active){
            advance_active = 1
            old_advance = horizon
            new_advance = horizon
        }
        if(old_advance>0 || new_advance>0) return
        old_advance = 0
        new_advance = 0
        advance_active = 0

        # Check the buffered horizon against the offset.  We want
        # sufficient lookahead to make strong, low-offset matches
        # before doing lots of subdivision.  Thus we want to avoid
        # making immediate high-offset matches that would prevent
        # better low-offset matches in the future.

        # Heuristic is to make sure that there's sufficient buffer
        # that the matching positions from above would still land in
        # the existing the buffer if the offset sign is flipped.

        if(!diff_eof){
            new_advance = pos["old"] + horizon - new_end + pos["off"]*2
            old_advance = pos["new"] + horizon - old_end - pos["off"]*2
            if(new_advance > 0 || old_advance > 0){
                advance_active = 1
                return
            }
        }

        # Recurse to subdivide
        set_exclusions(old_end)
        weak_split(pos["old"], pos["new"], match_words_max-1)

        # Upon returning, we've parsed, output, and removed the
        # regions that previously stretched from [0 .. old_pos)
        # and [0 .. newpos). Update our own subset and iterate.
        old_end -= pos["old"]
        new_end -= pos["new"]
    }
}

function list_map_error(i, j,
                        k, str){
    err("       Requested mapping ranges:")
    for(k=0; k < address_maps; k++) {
        if (k+1 < address_maps) {
            str = sprintf("       %d) src: [0x%08x..0x%08x) -> "        \
                          "dst [0x%08x..0x%08x)",k,
                          address_map_src[k],
                          address_map_src[k+1],
                          address_map_dst[k],
                          address_map_dst[k] +                          \
                          address_map_src[k+1] - address_map_src[k])
        } else {
            str = sprintf("       %d) src: [0x%08x..   EOF    ] -> "    \
                          "dst [0x%08x..   EOF    ]",k,
                          address_map_src[k],
                          address_map_dst[k])
        }
        if (k==i || k==j) {
            str=str" <<<"
        }
        err(str)
    }
    err("")
}

function sanity_check_maps(                                             \
                           i, j, k, lenA, startA, endA, len, start, end){
    for (i=0; i < address_maps-1; i++) {
        lenA = address_map_src[i+1] - address_map_src[i]
        startA = address_map_dst[i]
        endA   = address_map_dst[i] + lenA
        for (j=i+1; j < address_maps; j++) {
            if (j+1 < address_maps) {
                len = address_map_src[j+1] - address_map_src[j]
                start = address_map_dst[j]
                end   = address_map_dst[j] + len
                if (start < startA) start = startA
                if (end > endA) end = endA
                if (start < end) {
                    err(sprintf("ERROR: Mapped destination address"     \
                                " conflict from 0x%08x to 0x%08x",
                                start, end))
                    list_map_error(i,j)
                    exit(1)
                }
            } else {
                start = address_map_dst[j]
                end = start + 1
                if (start < startA) start = startA
                if (end > endA) end = endA
                if (start < end) {
                    err(sprintf("ERROR: Mapped destination address"     \
                                " conflict beginning at 0x%08x",
                                start))
                    list_map_error(i,j)
                    exit(1)
                }
                if (start < endA) {
                    err("ERROR: Possible destination address"           \
                        " conflict depending on length of input.")
                    err(sprintf("       Final mapping destination may"  \
                                " extend into mapping %d.",i))
                    list_map_error(i,j)
                    exit(1)
                }
            }
        }
    }
}

# Internally, address mapping regions are simple src/dest
# pairs. Regions are ordered and each region stretches to the
# next so that there are no holes.
function add_map(dst, src, len,
                 i, j, k, src_prev, dst_prev){
    if (address_maps == 0) {
        address_map_src[0] = 0
        address_map_dst[0] = 0
        address_maps = 1;
    }
    dst = strtonum(dst)
    src = strtonum(src)
    # find insertion point for start of map
    for(i=0; i < address_maps; i++) {
        if(address_map_src[i] >= src) break
    }
    if(len == ""){
        # unbounded address map; add one entry from
        # src/dest to end of file, replacing any later entries
        address_map_src[i] = src
        address_map_dst[i] = dst
        address_maps = i+1;
    } else {
        len = strtonum(len)
        # bounded address map; add two entries, one that enters the
        # map and one that exits it, potentially to some previously
        # specified map that is only being partially replaced.

        # find where this map ends.  loop below saves mapping entry
        # we're cutting/replacing.
        src_prev = 0
        dst_prev = 0
        for(j=0; j < address_maps; j++) {
            if(address_map_src[j] > src+len) break
            src_prev = address_map_src[j];
            dst_prev = address_map_dst[j];
        }
        # we'll insert two entries and delete i through j exclusive;
        # expand/contract list past i as needed
        if(2 > j-i) {
            # expand
            for(k=address_maps-1; k>=i; k--){
                address_map_src[k+2-j+i] = address_map_src[k];
                address_map_dst[k+2-j+i] = address_map_dst[k];
            }
        } else if (2 < j-i) {
            #contract
            for(k=i+2; k<address_maps; k++){
                address_map_src[k] = address_map_src[k+j-i-2];
                address_map_dst[k] = address_map_dst[k+j-i-2];
            }
        }
        address_maps += 2-j+i
        address_map_src[i+1] = src + len
        address_map_dst[i+1] = (src + len - src_prev) + dst_prev
        address_map_src[i] = src
        address_map_dst[i] = dst
    }
}

function setup_color() {
    fetch_tty_capability()
    if(tty_q(TTY_COLOR)){
        # address header/footer setup
        if(tty_q( TTY_UNDERLINE + TTY_INVISIBLE)){
            # can pretty-print the header/footer bars
            color_address_underline = TTY_UNDERLINE
            color_address_base = TTY_NOCOLOR
            color_address_bar = TTY_INVISIBLE
            color_address_midbar = TTY_INVISIBLE + TTY_STRIKEOUT
            color_address_diff = TTY_BOLD
        }else if (tty_q( TTY_STRIKEOUT + TTY_INVISIBLE )){
            # can't pretty-print underline, try strikeouts
            color_address_underline = TTY_NOCOLOR
            color_address_base = TTY_NOCOLOR
            color_address_bar = TTY_INVISIBLE + TTY_STRIKEOUT
            color_address_midbar = TTY_INVISIBLE + TTY_STRIKEOUT
            color_address_diff = TTY_BOLD
        }else{
            # can't pretty-print at all, lean into emdash
            color_address_underline = TTY_NOCOLOR
            color_address_base = TTY_NOCOLOR
            color_address_bar = TTY_NOCOLOR
            color_address_midbar = TTY_NOCOLOR
            color_address_diff = TTY_BOLD
        }

        # diff line entries
        color_block_base = TTY_NOCOLOR
        color_block_match = TTY_DIM
        color_block_oldlight = TTY_RED + TTY_BOLD
        color_block_newlight = TTY_GREEN + TTY_BOLD
        color_block_banglight = TTY_BOLD

        # map line entries
        color_map_base = TTY_DIM
        color_map_diff = TTY_DIM + TTY_BOLD

        # crc line entries
        color_crc_base = TTY_DIM
    }
}

function disable_color(){
    clear_tty_capability()
    color_address_base = 0
    color_address_underline = 0
    color_address_bar = 0
    color_address_midbar = 0
    color_address_diff = 0
    color_block_base = 0
    color_block_oldlight = 0
    color_block_newlight = 0
    color_block_banglight = 0
    color_map_base = 0
    color_map_diff = 0
    color_crc_base = 0
}

function stdout_usage(\
                      save_dev){
    save_dev=err_device
    err_device="/dev/stdout"
    usage()
    err_device=save_dev
}

function usage(){
    err("")
    err("diff32 : A 'diff'-style comparison tool for raw 32 bit binaries")
    err("")
    err("USAGE  : diff32 [OPTIONS] fileA.bin fileB.bin")
    err("")
    err("OPTIONS:")
    err("")
    err("  -c, --context=NUM")
    err("")
    err("     Include NUM lines of copied context before and after changes.")
    err("     Minimum value is 0, maximum is 16.  Default is 3.")
    err("")
    err("  -d, --dittomarks")
    err("")
    err("     Mark consecutive identical words in fileA or fileB with ditto")
    err("     marks (\" \"), rather than printing the literal values, in")
    err("     order to highlight runs of identical values.  Only lines where")
    err("     the fileA and fileB sides differ will be marked; context and")
    err("     other identical matching lines will not be marked.")
    err("")
    err("  -D, --no-dittomarks")
    err("")
    err("     Disable dittomarking.")
    err("")
    err("  -e, --elide=NUM")
    err("")
    err("     Perform output elision when it will shorten the output by NUM")
    err("     lines or more. Elision replaces runs of identical entries on the")
    err("     left or right side with a single line indicating the repeated")
    err("     word and number of times the word is repeated. Default NUM is 4.")
    err("")
    err("  -E, --no-elision")
    err("")
    err("     Disable elision.")
    err("")
    err("  -h, --help")
    err("")
    err("     Output this help message and exit.")
    err("")
    err("  -l, --minimum-match-length=NUM")
    err("")
    err("     Sets the minimum length in words of a match when performing")
    err("     subdivision of large regions.  NUM may be 1 through 32 (default")
    err("     is 1 words) and must be less than or equal to the initial")
    err("     match length.")
    err("")
    err("  -L, --initial-match-length=NUM")
    err("")
    err("     Sets the required match length in words when doing initial")
    err("     matching of large regions. NUM may be 1 through 32 (default")
    err("     is 8 lines/words) and must be greater than or equal to the")
    err("     minimum match length.")
    err("")
    err("  -m, --map=DESTINATION[,SOURCE[,LENGTH]]")
    err("")
    err("     Map displayed input byte range of LENGTH bytes starting at")
    err("     SOURCE byte offset to the range beginning at DESTINATION.  -m")
    err("     only affects displayed addresses, not match or output order.")
    err("     Omitting LENGTH extends range to the end of the file.  Omitting")
    err("     both SOURCE and LENGTH maps the entire input. More than one")
    err("     range may be specified. Later overlapping input ranges override")
    err("     earlier ranges. Final destination ranges may not overlap. Values")
    err("     may be decimal, octal (leading 0) or hexadecimal (leading 0x).")
    err("")
    err("  -n, --no-pager")
    err("")
    err("     Do not use a pager or format/color output for display on a")
    err("     terminal.  This overrides the default behavior of using a pager")
    err("     and colorized output when stdout is attatched to a terminal.")
    err("")
    err("  -p, --pager")
    err("")
    err("     Use a pager (default is \"less\") and colorize output (default")
    err("     behavior when stdout is attatched to a terminal).")
    err("")
    err("  -r, --redact-original")
    err("")
    err("     Redact fileA's words from the diff32 output by emitting changes")
    err("     as block deletions from fileA marked '.. .. .. .. <<<', followed")
    err("     by insertions from fileB. Context is set to zero, but may be")
    err("     over-ridden by following with -c LINES.  Redaction is intended to")
    err("     minimize the amount of information from fileA included in output.")
    err("")
    err("  -v, --version")
    err("")
    err("     Output version and exit.")
    err("")
    err("  -z, --extend-horizon=NUM")
    err("")
    err("     Add NUM additional words to the computed lookahead horizon when")
    err("     searching for initial matches with the lowest possible offsets.")
    err("     NUM may be between zero (disabling lookahead) and 4096. Higher")
    err("     values may produce better output at the cost of greatly increased")
    err("     computation time.  The default value is 32.")
    err("")
    err("  --color")
    err("")
    err("     Colorize the output.  Default behavior when using the default")
    err("     pager or outputting directly to a tty.")
    err("")
    err("  --no-color")
    err("")
    err("     Do not colorize the output.")
    err("")
    err("  --crc")
    err("")
    err("     Add running CRC32 checksum of both files and each output hunk")
    err("     to hunk and file footers. --crc is default behavior when stdout")
    err("     is not attached to a terminal. -n and -r imply also --crc.")
    err("")
    err("  --no-crc")
    err("")
    err("     Disable CRC32 checksumming. -p implies --no-crc.")
    err("")
    err("DETAILS:")
    err("")
    err("     diff32 is a gawk script that wraps the standard diff utility")
    err("     to produce a human- or machine-readable side-by-side text summary")
    err("     of differences between two raw 32-bit binary files. diff32 ")
    err("     searches for changes, insertions, and deletions. It can be used")
    err("     to manually inspect differences between two binary files, or as")
    err("     a automated format of binary patch interchange.")
    err("")
    err("EXAMPLES:")
    err("")
    err("  diff32 mips_binary1.bin mips_binary2.bin")
    err("")
    err("     Produce a colorized summary of the differences in binary files")
    err("     mips_binary1.bin and mips_binary2.bin, presented on the terminal")
    err("     one page at a time using the 'less' utility.")
    err("")
    err("  diff32 -r secret1 secret2")
    err("")
    err("     Produce a patch that specifies how to convert binary file secret1")
    err("     to file secret2 without including byte values from secret1. Hunk")
    err("     match verification is performed by location and checksum.")
    err("")
    err("  diff32 -m 0x600 -m 0,0x200,0x200 -m 0x400,0,0x200 overlay1 overlay2")
    err("")
    err("     View a paged/colorized difference summary between overlay1 and")
    err("     overlay2 adding map header entries reflecting where different")
    err("     portions of the file are mapped.  Maps can make diff32 output")
    err("     easier to compare to live memory locations when using tools such")
    err("     as Ghidra or IDA with overlays and compacted binaries.")
    err("")
    err("AUTHOR:")
    err("")
    err("     Written by Monty Montgomery <monty@xiph.org>")
    err("     This is free software: you are free to change and redistribute")
    err("     it.  There is NO WARRANTY, to the extent permitted by law.")
    err("")
    err("SEE ALSO:")
    err("")
    err("  patch32(1), diff(1), cmp(1), xdelta(1), gawk(1), less(1), infocmp(1)")
    err("")
}

function version () {
    q("  diff32 version 0.9.0, plus:")
    q_line()
    if ((cmd = "/usr/bin/gawk --version 2>/dev/null") | getline) {
        q("    "$0)
        close(cmd)
        q_line()
    }
    if ((cmd = DIFF" --version 2>/dev/null") | getline) {
        q("    "$0)
        close(cmd)
        q_line()
    }
    if ((cmd = LESS" --version 2>/dev/null") | getline) {
        q("    "$0)
        close(cmd)
        q_line()
    }
    if ((cmd = INFOCMP" -V 2>/dev/null") | getline) {
        q("    "$0)
        close(cmd)
        q_line()
    }
    q_line()
    q_line()
}

function opterr(msg){
    err("")
    err("diff32: "msg"")
    err("        See man page or diff32 --help for more information.")
    err("")
    close("/dev/stdout")
    exit(1)
}

function getopts(argc, argv,
                 i, j, options_done, options, argument, pos){
    options_done = 0;
    for(i=1; i<argc; i++){
        option = ""
        delete argument
        if (!options_done){
            if (argv[i] == "--") {
                options_done = 1
            } else {
                if (substr(argv[i],1,2) == "--"){
                    pos = index(argv[i],"=")
                    if (pos>0) {
                        option = substr(argv[i],3,pos-3)
                        split(substr(argv[i],pos+1),argument,",")
                    } else {
                        option = substr(argv[i],3)
                    }
                } else if (substr(argv[i],1,1) == "-"){
                    if(length(argv[i])>2){
                        opterr("Error parsing command line argument.")
                    }
                    option = substr(argv[i],2)
                    split(argv[i+1],argument,",")
                } else {
                    if (fileA == "") {
                        fileA = argv[i]
                        continue
                    } else if (fileB =="") {
                        fileB = argv[i]
                        continue
                    } else {
                        opterr("Too many files specified on command line.")
                    }
                }
                if (option == "c" || option == "e" || option=="l" || option=="L" ||
                    option== "m" || option == "z"){
                    i++ # advance past argument
                }
                if (option == "c" || option == "context"){
                    if (argument[1] == "" || argument[2] != "") {
                        opterr("Context takes a single argument.")
                    }
                    context = strtonum(argument[1]);
                    if(context < 0 || context > 16){
                        opterr("Context argument must be in the range 0..16.")
                    }
                }else if (option == "d" || option == "dittomarks"){
                    ditto_active = 1
                }else if (option == "D" || option == "no-dittomarks"){
                    ditto_active = 0
                } else if (option == "e" || option == "elide") {
                    if (argument[1] == "" || argument[2] != "") {
                        opterr("Elide takes a single argument.")
                    }
                    elision_active = 1
                    elision_thresh = strtonum(argument[1])+1;
                    if(elision_thresh < 2){
                        opterr("Elision argument must be greater than 0.")
                    }
                }else if (option == "E" || option == "no-elision"){
                    elision_active = 0
                } else if (option == "r" || option == "redact-original") {
                    redact_active = 1
                    elision_active = 1
                    elision_thresh = 4
                    ditto_active = 1
                    crc_active = 1
                    context = 0
                } else if (option == "l" || option == "minimum-match-length") {
                    if (argument[1] == "" || argument[2] != "") {
                        opterr("Minimum match length takes a single argument.")
                    }
                    match_words_min = strtonum(argument[1]);
                    if(match_words_min < 1 || match_words_min>32){
                        opterr("Minimum match length must be in the range 1..32.")
                    }
                } else if (option == "L" || option == "initial-match-length") {
                    if (argument[1] == "" || argument[2] != "") {
                        opterr("Initial match length takes a single argument.")
                    }
                    match_words_max = strtonum(argument[1]);
                    if(match_words_max < 1 || match_words_max>32){
                        opterr("Initial match length must be in the range 1..32.")
                    }
                } else if (option == "h" || option == "help") {
                    stdout_usage()
                    exit(0)
                } else if (option == "m" || option == "map") {
                    if (argument[1] == "" || argument[4] != "") {
                        opterr("Map option takes one to three comma-separated arguments.")
                    }
                    add_map(argument[1],argument[2],argument[3])
                } else if (option == "n" || option == "no-pager") {
                    # the actual paging setup is handled by the shell wrapper
                    disable_color()
                    crc_active = 1
                } else if (option == "p" || option == "pager") {
                    # the actual paging setup is handled by the shell wrapper
                    setup_color()
                    if (!redact_active) crc_active = 0
                } else if (option == "v" || option == "version") {
                    version()
                    exit(0)
                } else if (option == "z" || option == "extend-horizon"){
                    if (argument[1] == "" || argument[2] != "") {
                        opterr("Horizon option takes a single argument.")
                    }
                    horizon = strtonum(argument[1]);
                    if(horizon < 0 || horizon > 4096){
                        opterr("Horizon argument must be in the range 0..4096.")
                    }
                } else if (option == "color") {
                    setup_color()
                } else if (option == "no-color") {
                    disable_color()
                } else if (option == "crc") {
                    crc_active = 1
                } else if (option == "no-crc") {
                    crc_active = 0
                } else {
                    opterr("Unknown arguemnt on command line.")
                }
            }
        } else {
            if (fileA == "") {
                fileA = argv[i]
            } else if (fileB =="") {
                fileB = argv[i]
            } else {
                opterr("Too many files specified on command line.")
            }
        }
    }

    if(fileA == "" || fileB == ""){
        opterr("Missing input file(s).")
    }

    if(match_words_min>match_words_max){
        opterr("Minimum match length must be less than or equal to initial match length.")
    }
    sanity_check_maps()
}

function output_maps(\
                     k){
    for(k=0; k < address_maps; k++) {
        q(sprintf("MAP: 0x%08x -> 0x%08x",
                    address_map_src[k],
                    address_map_dst[k]))
        q_line()
    }
    if(address_maps) q_line()
}

function find_util(path, envvar, report,
                   cmd){
    if(ENVIRON[envvar])path = ENVIRON[envvar]
    cmd = "command -v "path
    cmd|getline
    close(cmd)
    if(!$0 && report) err("diff32: Can't find '"path"' utility in the path.")
    return $0
}

BEGIN {
    # arguments
    context = 3
    swap = 0
    redact_active = 0
    crc_active=1
    ditto_active=1
    elision_active=1
    elision_thresh=5
    match_words_min = 1
    match_words_max = 8
    horizon = 32

    # global state variables
    old_cursor=0
    new_cursor=0
    old_count=0
    new_count=0
    old_advance=0
    new_advance=0
    old_crc=0
    new_crc=0
    advance_active=0
    diff_eof=0
    context_count=0
    new_block=1
    hunks=0
    address_maps=0
    err_device="/dev/stderr"

    DIFF = find_util("diff", "DIFFPROG", 1)
    LESS = find_util("less", "PAGER", 1)
    INFOCMP = find_util("infocmp", "INFOCMP", 0)
    getopts(ARGC, ARGV)
    if(crc_active)init_crc()

    # Convert binary input to undecorated hexadecimal ASCII.
    # This outputs a line per word, however each line consists of the
    # current word and the previous match_words_max-1 words as well.
    # This way we match on multiple words but with granularity.
    textify_cmd="LC_ALL=C /usr/bin/gawk '                               \
        BEGIN {\n                                                       \
            BINMODE = 3\n                                               \
            RS = \"[\\0-\\xff]{4}\"\n                                   \
            for(i=0;i<256;i++){\n                                       \
                f=sprintf(\"%c\",i)\n                                   \
                t=sprintf(\"%02x\",i)\n                                 \
                tohex[f]=t\n                                            \
            }\n                                                         \
        }\n                                                             \
        {\n                                                             \
            if(RT){\n                                                   \
                # normal case: grabbed four bytes\n                     \
                word = \"\"tohex[substr(RT,1,1)]\n                      \
                for(i=2;i<=4;i++) word = word\"\"tohex[substr(RT,i,1)]\n \
                line = \"w\"word\"\"substr(line,1,"match_words_max"*9-9)\n \
                print line\n                                            \
            }else{\n                                                    \
                # error case: should only happen if EOF happens\n       \
                # before a full 4 bytes\n                               \
                l = length($0)\n                                        \
                if(l<1 || l>3) exit(1)\n                                \
                word = \"\"tohex[substr($0,1,1)]\n                      \
                for(i=2;i<=l;i++) word = word\"\"tohex[substr($0,i,1)]\n \
                for(i;i<=4;i++) word = word\"  \"\n                     \
                line = \"w\"word\"\"substr(line,1,"match_words_max"*9-9)\n \
                print line\n                                            \
                exit(0)\n                                               \
           }                                                            \
        }'"
    diff_cmd=DIFF" "                                                    \
        "--old-line-format=$'< %l\n' "                                  \
        "--new-line-format=$'> %l\n' "                                  \
        "--unchanged-line-format=$'= %l\n' "                            \
        "-- "                                                           \
        "<("textify_cmd" \""fileA"\") "                                 \
        "<("textify_cmd" \""fileB"\") "
    output_maps()
    q("")
    while(!ERRNO && (diff_cmd | getline) > 0){
        line = $2
        if ($1=="="){
            push_old_line(line)
            push_new_line(line)
            strong_split(old_count, new_count)
        } else if ($1=="<") {
            push_old_line(line)
        } else if ($1==">") {
            push_new_line(line)
        }
    }
    diff_eof = 1
    # flush each stage of the diff handling pipeline
    strong_split(old_count, new_count)
    output_split(old_count, new_count)
    print_end()
    close(diff_cmd)
    close("/dev/stdout")
}

############################ diff32 gawk script ends ############################
#EOF
############################ back to the bash wrapper ###########################

_interrupt() {
  # Immediate kill 0 won't do what we want; it kills us too.
  # The pager must fully exit first.
  kill -INT $pager_pid
  wait $pager_pid
  # now kill 0 will do what we want
  kill -TERM 0
}

# default pager utility and options if not locally set
if [ -z "${PAGER}" ]; then
  export PAGER="less -R -K -M -X -F"
fi

# default diff utility and options if not locally set
if [ -z "${DIFFPROG}" ]; then
  export DIFFPROG="diff"
fi

# Test for interactive terminal and pager executable;
# if both present, default to using the configured pager.
[[ ! ( -t 1 && -x $(command -v $PAGER)) ]]
use_pager=$?

# Allow user to override default pager use.
# Scan arguments without clobbering them.
args=( "$@" )
while test $# -gt 0
do
    case "$1" in
        -p|--pager)
          use_pager=1
            ;;
        -n|--no-pager|-v|--version|-h|--help)
          use_pager=0
            ;;
    esac
    shift
done

if [ $use_pager == 1 ]; then
  ####################### pager case ############################
  # exec script, get output fd and pid.
  exec {diff32_fd}< <(gawk -f - -- "--pager" "${args[@]}" <&$script_fd) ; script_pid=$!
  # Trap interrupts before starting pager.
  trap _interrupt INT
  # Connect pager to script, get pager fd.
  $PAGER $PAGER_ARGS <&$diff32_fd & pager_pid=$!
  # Gate on the pager.
  wait $pager_pid
  # Done. Issue a kill to clean up children if pager quit before
  # diffing completed, and script didn't notice for some reason
  # (it should have, but might be stuck for some other reason).
  trap '' INT
  kill -INT 0
else
  ##################### non-pager case ##########################
  # run script.
  gawk -f - -- "${args[@]}" <&$script_fd
fi
