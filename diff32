#!/usr/bin/awk -E

# helper function to print the input to_print, optionally colorizing
# the nibbles that match the comparison input to_compare using
# the escape sequence 'off', and the nibbles that do not match with 'on'.
# 'lock' is nonzero if a color change to 'on' should persist for the
# rest of the string regardless of match; this is used to highlight
# address differences.
function print_highlight(to_print, to_compare, off, on, lock,
                         current, a, b, i){
    current = off
    for(i=1; i<=length(to_print); i++){
        a = substr(to_print,i,1)
        b = substr(to_compare,i,1)
        if (a != b){
            if (current == off) {
                if (lock) {
                    current = lock
                }else{
                    current = on
                }
                printf on
            }
        } else {
            if (current == on) {
                current = off;
                printf off
            }
        }
        printf a
    }
    if (current != off) printf off
}

# print an address header at the beginning of a new block of differences.
function print_address(old, new,
                       old_addr, new_addr){
    printf " "color_address_base
    old_addr = sprintf("0x%08x",old)
    new_addr = sprintf("0x%08x",new)
    print_highlight(old_addr,new_addr,color_address_base,color_address_old,1);
    if(color_address_base){
        printf "       "
    }else{
        printf " ----- "
    }
    print_highlight(new_addr,old_addr,color_address_base,color_address_new,1);
    printf color_off"\n"
}

# print one line of a diff block
function print_line(old, c, new) {
    if(c == " "){
        printf color_bytes_unchanged" %s  %s  %s"color_off, old, c, new
    }else{
        printf " "
        print_highlight(old,new,color_off,color_bytes_old,0);
        if (c == "<") {
            printf color_bytes_old
        } else if (c == ">" ){
            printf color_bytes_new
    } else if (c == "!" ){
            printf color_bytes_changed
        }
        printf "  %s  "color_off, c
        print_highlight(new,old,color_off,color_bytes_new,0);
    }
    printf "\n"
}

# simple abs() function as there's no relaibly available built-in
function abs(v){
    if(v<0)v= -v
    return v
}

# Compare the binary strings A and B, each consisting of 4 octets
# separated by spaces, each octet containing the characters '1' or
# '0', and produce a similarity score.  The scoring works 8 bits at a
# time, partly to avoid any issues with endianness.  It counts runs of
# matching characters, weights each run, and sums the weighted run
# values into a raw score. Finally, we adjust this score, reducing it
# according to a basic entropy measure (ie, if our input is nearly all
# zeros or nearly all ones, there's probably not much actual entropy
# there.  Think of long 'empty' runs of 0x00000000 or 0xffffffff in
# typical binaries; fuzzy matching needs to mostly disregard them).
function score_line(A, B,
                    i, j, ones, run_total, run, Ab, Bb, score){
    ones = 0
    run_total = 0

    for (j=1; j <=35; j+=9) {
        run = 1
        for (i=0; i<8; i++) {
            Ab = substr(A,i+j,1)
            Bb = substr(B,i+j,1)
            if (Ab == "0") {
                if(Bb == "0") {
                    run++
                } else {
                    ones++
                    run_total += run_weight[run]
                    run = 1
                }
            } else {
                ones++
                if(Bb == "1") {
                    ones++
                    run++
                } else {
                    run_total += run_weight[run]
                    run = 1
                }
            }
        }
        run_total += run_weight[run]
    }
    score = run_total - entropy_weight[abs(32-ones)+1]
    if(score < 0) score = 0
    return score
}

# Computes a fuzzy match score for the currently loaded old/new lines,
# overlapped by the passed in offset.
function compute_match(offset,
                       i, score, value, max, start, count) {
    score = 0
    max = 0

    # Deemphasis reduces short match scores relative to long matches,
    # as their smaller samples size makes strong high scores
    # relatively more likely.
    count = small_match_derate

    if(offset < 0) {
        start = 0
    } else {
        start = offset;
    }
    for(i=start; i<old_count && i<new_count+offset; i++){
        value = score_line(old_line[i],new_line[i-offset])
        if (value>max) max = value
        score += value
        count++
    }
    if(count <= 0) return 0

    # Make score relative to match size.
    score /= count

    # Reject weak matches.  A 'weak match' is a maximum match score of
    # less than ~ 8 contiguous bits and an overall average score of
    # lewss than half that maximum.
    if (max < weighted_fuzzy || score < weighted_fuzzy/2)
        return -1

    # Weight toward the zero offset
    if(offset == 0) {
        score = zero_weight*(score+zero_offset)
    }
    return score
}

# overlap offset is the amount by which the new_lines block is offset
# relative to the old_lines block.  Negative indicates the new_lines
# start first, positive indicates new_lines beginning follows
# old_lines beginning.
function overlap_stored_diff(\
    i, best_overlap, best_score, score) {
    # Diff hands all changes to us as a set of < lines and then >
    # lines.  Diff does not do fuzzy matching, and we probably don't
    # want to mangle together a diff incant that tries. We look for
    # overlaps using partial matches ourselves here.

    # always present isolated single-line changes are overlaps.
    if(old_count == 1 && new_count == 1) return 0

    # If we have only one set of changes (pure deletion or pure insertion)
    # there's no point in checking further.
    if(old_count == 0 || new_count == 0) return 0

    # Don't try to overlap large changes; the search will take too
    # long, and it's not clear to me we're likely to find a good match
    # anyway.  If this guess proves wrong, we can try harder in the future.
    if(old_count > 256 && new_count > 256) return old_count

    # Search for overlap by comparing each offset.
    # Choose the high score as our match, break ties by closest to zero.
    best_overlap = 0
    best_score = compute_match(0)

    for (i=1; i<=old_count || i<=new_count; i++) {
        if (i<=old_count) {
            score = compute_match(i)
            if(score > best_score) {
                best_overlap = i;
                best_score = score;
            }
        }
        if (i<=new_count) {
            score = compute_match(-i)
            if(score > best_score) {
                best_overlap = -i;
                best_score = score;
            }
        }
    }

    # If we found no strong matches, best score will be -1.  In this
    # case, return a non-overlap, that is, deletions followed by
    # insertions.
    if (best_score == -1) return old_count

    return best_overlap
}

# Input from od is hexadecimal octets separated by spaces.  Output is
# binary octets separated by spaces. Input order is preserved (order
# of the octets themselves is irrelevant to the fuzzy matching).
function tobinary(hex_input_line,
                  i, ret) {
    ret=""
    for(i=1; i<=length(hex_input_line); i++){
        ret = ret""binary_nibbles[substr(hex_input_line,i,1)]
    }
    return ret
}

# map from internal binary strings back to space-separated hex
# octets for printing
function tohex(binary_input_line,
                  i, j, n0, n1, ret){
    ret = ""
    for(i=1; i+7<=length(binary_input_line); i+=9) {
        n0 = 0
        n1 = 0
        for(j=0; j<4; j++)
            n0 = (n0*2) + substr(binary_input_line,i+j,1)+0
        for(; j<8; j++)
            n1 = (n1*2) + substr(binary_input_line,i+j,1)+0
        if (i==1){
            ret = sprintf("%x%x",n0,n1)
        } else {
            if (swap) {
                ret = sprintf("%x%x %s",n0,n1,ret)
            } else {
                ret = sprintf("%s %x%x",ret,n0,n1)
            }
        }
    }
    return ret
}

function print_stored_diff(                                     \
    old_start, new_start, diff_start, overlap_offset, i) {
    old_start = old_cursor - old_count*4;
    new_start = new_cursor - new_count*4;

    if (context_count >= context || beginning) {
        # post-context has run out, or we're at/near beginning of file.
        # Skip a line for visual break and print an address header.
        if (!beginning) printf "\n"
        print_address(old_start, new_start)
        beginning=0
    }
    # print any pending pre-context
    for(i=context_count;i>0;i--) {
        print_line(context_line[i-1]," ",context_line[i-1])
    }

    # the actual differing lines
    if (fuzzy) {
        overlap_offset = overlap_stored_diff()
    } else {
        overlap_offset = old_count
    }
    if(overlap_offset < 0) {
        diff_start = overlap_offset;
    } else {
        diff_start = 0;
    }
    for(i=diff_start; i<old_count || i<new_count+overlap_offset; i++){
        if(i>=0 && i<old_count){
            if(i>=overlap_offset && i<new_count+overlap_offset){
                # Although I don't think diff will ever return any
                # matching lines in the diff segments, handle the
                # possibility.
                if(old_line[i] == new_line[i-overlap_offset]){
                    print_line(tohex(old_line[i]),
                               " ",
                               tohex(new_line[i-overlap_offset]))
                } else {
                    print_line(tohex(old_line[i]),
                               "!",
                               tohex(new_line[i-overlap_offset]))
                }
            } else {
                print_line(tohex(old_line[i]),"<","           ")
            }
        }else{
            print_line("           ",">",tohex(new_line[i-overlap_offset]))
        }
    }
    old_count=0
    new_count=0
    context_count= -context
}

function print_end(){
    printf "\n ----------- END ----------- \n"
}

function usage(){
    print ""
    print "diff32 : A 'diff'-style comparison tool for raw 32 bit binaries"
    print ""
    print "USAGE  : diff32 [OPTIONS] file1.bin file2.bin"
    print ""
    print "OPTIONS:"
    print ""
    print "  -c, --context=NUM"
    print ""
    print "     Include NUM lines of copied context before and after changes."
    print "     Minimum value is 0, maximum is 16.  Default is 3."
    print ""
    print "  -d, --minimal"
    print ""
    print "     Try hard to find a smaller set of changes."
    print ""
    print "  -f, --fuzzy=NUM"
    print ""
    print "     Adjust the matching threshold that diff32 uses to present two"
    print "     regions as overlapping/similar using '!', instead of deletions"
    print "     '<' followed by insertions '>'. Fuzzy matching is nonlinear, but"
    print "     the value roughly sets the minimum sequence of matching bits to"
    print "     consider two words a loose match.  Note that single-line"
    print "     changes are always presented as '!' regardless of match."
    print "     Minimum value is 0, max is 32. Default is 16 (two 8-bit bytes)."
    print ""
    print "  -h, --help"
    print ""
    print "     Print this help messae and exit."
    print ""
    print "  -n, --no-fuzzy"
    print ""
    print "     Do not perform 'fuzzy' overlap matching.  Presents output"
    print "     as deletions ('<') followed by insertions ('>') only, with no"
    print "     change ('!') lines."
    print ""
    print "  -s, --swap-endian"
    print ""
    print "     diff32 normally presents bytes in as-read order. -s instructs"
    print "     diff32 to swap the order it prints bytes on each line. -s has"
    print "     no effect on matching, which is endian-agnostic."
    print ""
    print "  -v, --version"
    print ""
    print "     Print version and exit."
    print ""
    print "  --color"
    print ""
    print "     Colorize the output."
    print ""
    print "DETAILS:"
    print ""
    print "     diff32 is an awk script wrapping the od and diff utilities"
    print "     that produces a human-readable side-by-side text summary of"
    print "     differences between two raw 32-bit binary files."
    print ""
    print "     diff32 searches for insertions, deletions, and co-located"
    print "     changes. By default, it will also perform fuzzy matching to"
    print "     align regions of similar content."
    print ""
    print "EXAMPLE:"
    print ""
    print "  diff32 -d --color mips_binary1.bin mips_binary2.bin | less -R"
    print ""
    print "     Produce a colorized summary of the differences in binary files"
    print "     mips_binar1.bin and mips_binary2.bin, presented on the terminal"
    print "     one page at a time using the 'less' utility. The -d option to"
    print "     diff32 requests extra time be spent to minimize the change"
    print "     set. The -R option instructs less to allow ANSI color codes."
    print ""
    print "AUTHOR:"
    print ""
    print "     Written by Monty Montgomery <monty@xiph.org>"
    print "     This is free software: you are free to change and redistribute"
    print "     it.  There is NO WARRANTY, to the extent permitted by law."
    print ""
    print "SEE ALSO:"
    print ""
    print "  od(1), diff(1), cmp(1), xdelta(1)"
    print ""
}

function version () {
    print ""
    print "diff32 version 0.0.0"
    if ("awk --version" | getline) {
        print $0
    }
    if ("diff --version" | getline) {
        print $0
    }
    if ("od --version" | getline) {
        print $0
    }
    print ""
}

function getopts(argc, argv,
                 i, j, options_done, options, argument){
    options_done = 0;
    for(i=1; i<argc; i++){
        option = ""
        argument = ""
        if (!options_done){
            if (argv[i] == "--") {
                options_done = 1
            } else {
                if (substr(argv[i],1,2) == "--"){
                    pos = index(argv[i],"=")
                    if (pos>0) {
                        option = substr(argv[i],3,pos-3)
                        argument = substr(argv[i],pos+1)
                    } else {
                        option = substr(argv[i],3)
                    }
                } else if (substr(argv[i],1,1) == "-"){
                    if(length(argv[i])>2){
                        usage()
                        exit(1)
                    }
                    option = substr(argv[i],2)
                    argument = argv[i+1]
                } else {
                    if (fileA == "") {
                        fileA = argv[i]
                        continue
                    } else if (fileB =="") {
                        fileB = argv[i]
                        continue
                    } else {
                        usage()
                        exit(1)
                    }
                }
                if (option == "c" || option == "f"){
                    i++ # advance past argument
                }
                if (option == "c" || option == "context"){
                    if (argument == "") {
                        usage()
                        exit(1)
                    }
                    context = strtonum(argument);
                    if(context < 0 || context > 16){
                        usage()
                        exit(1)
                    }
                } else if (option == "d" || option == "minimal") {
                    minimal = "-d "
                } else if (option == "f" || option == "fuzzy") {
                    if (argument == "") {
                        usage()
                        exit(1)
                    }
                    fuzzy_threshold = strtonum(argument);
                    if(fuzzy_threshold < 0 || fuzzy_threshold>32){
                        usage()
                        exit(1)
                    }
                } else if (option == "h" || option == "help") {
                    usage()
                    exit(0)
                } else if (option == "n" || option == "no-fuzzy") {
                    fuzzy = 0
                } else if (option == "s" || option == "swap-endian") {
                    swap = 1
                } else if (option == "v" || option == "version") {
                    version()
                    exit(0)
                } else if (option == "color") {
                    color = 1
                } else {
                    usage()
                    exit(1)
                }
            }
        } else {
            if (fileA == "") {
                fileA = argv[i]
            } else if (fileB =="") {
                fileB = argv[i]
            } else {
                usage()
                exit(1)
            }
        }
    }

    if(fileA == "" || fileB == ""){
        usage()
        exit(1)
    }
}

BEGIN {
    context=3
    color=0
    minimal=""
    fuzzy_threshold=16
    fuzzy=1
    swap=0
    # weight slightly toward zero offset
    zero_offset = 2
    zero_weight = 1.10
    small_match_derate = 1

    old_cursor=0
    new_cursor=0
    old_count=0
    new_count=0
    context_count=0
    beginning=1
    weighted_fuzzy=0

    getopts(ARGC, ARGV)

    binary_nibbles[" "] = " "
    binary_nibbles["0"] = "0000"
    binary_nibbles["1"] = "0001"
    binary_nibbles["2"] = "0010"
    binary_nibbles["3"] = "0011"
    binary_nibbles["4"] = "0100"
    binary_nibbles["5"] = "0101"
    binary_nibbles["6"] = "0110"
    binary_nibbles["7"] = "0111"
    binary_nibbles["8"] = "1000"
    binary_nibbles["9"] = "1001"
    binary_nibbles["a"] = "1010"
    binary_nibbles["b"] = "1011"
    binary_nibbles["c"] = "1100"
    binary_nibbles["d"] = "1101"
    binary_nibbles["e"] = "1110"
    binary_nibbles["f"] = "1111"

    split("0 1 2 4 8 12 16 20 28 ",
          run_weight,
          " ")

    while (fuzzy_threshold > 8) {
        weighted_fuzzy += run_weight[9]
        fuzzy_threshold -= 8
    }
    weighted_fuzzy += run_weight[fuzzy_threshold+1]

    split("0 0 0 0 0 0 0 0 0 "                  \
          "0 0 0 0 0 0 1 2 "                    \
          "3 4 5 6 8 10 12 14 "                 \
          "16 20 24 28 32 50 74 112 ",
          entropy_weight,
          " ")

    if (color) {
        color_address_base = "\033[0;4m"
        color_address_old = "\033[0;1;4m"
        color_address_new = "\033[0;1;4m"
        color_bytes_unchanged = "\033[0;2m"
        color_bytes_old = "\033[0;31;1m"
        color_bytes_new = "\033[0;32;1m"
        color_bytes_changed = "\033[0;1m"
        color_off = "\033[0m"
    } else {
        color_address_base = ""
        color_address_old = ""
        color_address_new = ""
        color_bytes_unchanged=""
        color_bytes_old=""
        color_bytes_new=""
        color_bytes_changed=""
        color_off=""
    }
    od_cmd="od -Anone -tx1 -w4 -v --"
    diff_cmd="diff "                                                    \
        minimal                                                         \
        "--old-line-format=$'< %l\n' "                                  \
        "--new-line-format=$'> %l\n' "                                  \
        "--unchanged-line-format=$'= %l\n' "                            \
        "-- "                                                           \
        "<("od_cmd" "fileA") "                                          \
        "<("od_cmd" "fileB") "                                          \

    while(diff_cmd | getline){
        if ($1=="="){
            line = tobinary($2" "$3" "$4" "$5)
            if(new_count>0 || old_count>0) {
                print_stored_diff()
            }
            if(context_count<0){
                # running out post-context
                print_line(tohex(line), " ", tohex(line) )
            } else {
                # saving up pre-context
                for(i=context_count;i>0;i--) {
                    context_line[i]=context_line[i-1]
                }
                context_line[0] = tohex(line)
            }
            old_cursor+=4
            new_cursor+=4
            if( context_count < context) {
                context_count++
            }
        } else if ($1=="<") {
            line = tobinary($2" "$3" "$4" "$5)
            old_line[old_count++]=line
            old_cursor+=4
        } else if ($1==">") {
            line = tobinary($2" "$3" "$4" "$5)
            new_line[new_count++]=line
            new_cursor+=4
        }
    }
    if(new_count>0 || old_count>0) print_stored_diff()
    if(!beginning) print_end()
 }
