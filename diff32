# -*-Awk-*-
#!/bin/sh

########################### diff32 bash paging wrapper ##########################
# Implements process/pipe/signal handling for use of a default pager with the
# diff32 gawk script. gawk doesn't offer any signal handling, thus this wrapper.
#
# We want ^C (SIGINT) to interrupt any in-progress/runaway computation but also
# cleanly exit a pager.  The pager must exit first, else the terminal gets
# clobbered by out-of-order cleanup.
#
# The wrapper also makes sure ^C really shuts down everything. If gawk gets hung
# in a loop or due to a bug, it won't notice that stdout/stderr simply went away.
# After the pager exits, the interrupt handler issues a kill 0.
#################### bash script continues after gawk section ###################

exec {script_fd}<<'#EOF'

############################### diff32 gawk script ##############################
#!/usr/bin/gawk -E   # Unnecessary, seems clearer to include it.

#---------------------------------------------------------------------
#            POSIX CRC32 implementation.  Self-contained, no side
#            effects outside this layer.  init() creates a global
#            crc_table[] lookup.
#
#            The values calculated and printed are compatible with GNU
#            cksum, which includes byte count in the calculation.
#            Calculation is byte-reversed (not bitreversed) from the
#            usual inplementations, so the printed results must bre
#            byteswapped before printing.

# input: single numeric byte, integer crc state
function crc32_byte(v, crc) {
    return xor(rshift(crc, 8), crc_table[and(xor(crc,v),0xff)])
}

# Initialize the crc lookup table.
function init_crc(                              \
                  i, j, a, b, c, d){
    for(i=0;i<256;i++){
        a = i
        b = 0
        c = 0
        d = 0
        for(j=0;j<8;j++){
            a = lshift(a,1)
            b = lshift(b,1)
            c = lshift(c,1)
            d = lshift(d,1)
            if(!and(a,0x100))continue
            a = xor(a,0x04)
            b = xor(b,0xC1)
            c = xor(c,0x1D)
            d = xor(d,0xB7)
        }
        a = and(xor(a,rshift(b,8)),0xff)
        b = and(xor(b,rshift(c,8)),0xff)
        c = and(xor(c,rshift(d,8)),0xff)
        d = and(                 d,0xff)
        crc_table[i] = lshift(d,24)+lshift(c,16)+lshift(b,8)+a
    }
}

# byteswap for printing CRC32 values that match cksum.
function byteswap4(v,
                   i, r){
    for(i=0;i<4;i++){
        r = lshift(r,8)
        r = r + and(v,0xff)
        v = rshift(v,8)
    }
    return r
}

# add a byte length to a naked checksum, complement, and bytereverse
# for printing cksum compatible results.
function gnuify_crc32(crc, bytelength){
    while(bytelength){
        crc = crc32_byte(and(bytelength,0xff),crc)
        bytelength = rshift(bytelength,8)
    }
    return byteswap4(and(compl(crc),0xffffffff))
}

#---------------------------------------------------------------------
#            Line-buffered data output layer.  No side effects outside
#            this layer, though it access variables from the terminal
#            setup layer.
#
#            Global state: output_q_buffer
#                          output_q_lineready
#                          current_q_attribute
#
#            Read-only:    attribute_underline
#                          attributes_off
#                          err_device
#
#            The line buffer layer queues pieces of a line (or lines
#            really) to be explicitly flushed.  The goal here is not
#            performance, but to allow us to go back and alter the
#            pretty-printing on block boundaries (specifically a block
#            end/footer), without having to work ahead by arbitrary
#            amount.  It also tracks the last set ANSI attribute
#            string set by pretty-printing and does not re-emit if the
#            same setting is requested again.

# Accepts a string fragment to add to the queue. Optional argument
# sets the passed ANSI escape attributes if not already set to the
# same string.  Omitting the optional argument emits the sequence to
# disable attributes.
function q(string, attribute){
    if (output_q_lineready) q_flush()
    if (!attribute) attribute = attributes_off
    if (current_q_attribute != attribute) {
        output_q_buffer = output_q_buffer""attribute
        current_q_attribute = attribute
    }
    output_q_buffer = output_q_buffer""string
}

# underlines the text present in the line buffer, assuming
# terminal supports the operation. Cosmetic pretty-print.
function q_underline(){
    if(attribute_underline){
        # quick and dirty; 'm' only occurs in output when in ANSI escapes
        gsub("m",";4m",output_q_buffer)
        output_q_buffer = "\033[4m"output_q_buffer
    }
}

function q_line(){
    if (output_q_lineready) q_flush()
    if (current_q_attribute && current_q_attribute != attributes_off){
        output_q_buffer = output_q_buffer""attributes_off
        current_q_attribute = attributes_off
    }
    output_q_buffer = output_q_buffer"\n"
    output_q_lineready = 1
}

function q_flush(){
    printf output_q_buffer
    output_q_lineready = 0
    output_q_buffer = ""
}

# Program error output
function err(string){
    print string > err_device
}






# Takes a string of bytes formatted as space-separated hex doubles.
# updates the cursors and performs crc if active.
function bytecount_old_word(old_word,
                            i, n, hex) {
    n = split(old_word, hex, " ")
    old_cursor += n
    if(crc_active){
        for (i=1;i<=n;i++) {
            old_crc = crc32_byte(strtonum("0x"hex[i]),old_crc)
        }
    }
}

# Takes a string of bytes formatted as space-separated hex doubles.
# updates the cursors and performs crc if active.
function bytecount_new_word(new_word,
                            i, n, hex) {
    n = split(new_word, hex, " ")
    new_cursor += n
    if(crc_active){
        for (i=1;i<=n;i++) {
            new_crc = crc32_byte(strtonum("0x"hex[i]),new_crc)
        }
    }
}

# helper function to print the input, optionally colorizing the
# nibbles that match the comparison input to_compare using the escape
# sequence 'off', and the nibbles that do not match with 'on'.  'lock'
# is nonzero if a color change to 'on' should persist for the rest of
# the string regardless of match; this is used to highlight address
# differences.
function out_highlight(to_print, to_compare, off_color, on_color, lock,
                       current, a, b, c, i){
    if (to_print == " ") {
        to_print = "            "
    }
    c=off_color
    for(i=1; i<=length(to_print); i++){
        a = substr(to_print,i,1)
        b = substr(to_compare,i,1)
        if(a != " "){
            if (a != b){
                c = on_color
            } else {
                if (!lock) c=off_color
            }
        }
        q(a,c)
    }
}

# Run an absolute address offset from beginning-of-file through
# the user-supplied maps to arrive at a display address.
function map_an_address(addr,
                        i){
    for (i=0; i<address_maps; i++) {
        if (address_map_src[i] <= addr) {
            addr = address_map_dst[i] + addr - address_map_src[i]
            break
        }
    }
    return addr
}

# Print an address footer at the end of a preceding block of differences.
function print_address_footer(                                  \
                              old, new, old_str, new_str){

    # Don't print a footer if there's no preceding block.
    if (hunks){
        # print crc for footer if active
        if(crc_active){
            # crc
            q(sprintf(" 0x%08x  crc  0x%08x ",
                      gnuify_crc32(block_old_crc,block_old_cursor),
                      gnuify_crc32(block_new_crc,block_new_cursor)),
              color_address_deemph)
            q_line()
        }
        # Pretty-print for terminals; add an underline to the last
        # word entry.
        q_underline()
        # Print current addresses for footer.
        old_str = sprintf("0x%08x",block_old_cursor)
        new_str = sprintf("0x%08x",block_new_cursor)
        out_highlight(" "old_str," "new_str,color_address_base,color_address_diff,1);
        q(" ----- ",color_bar)
        out_highlight(new_str" ",old_str" ",color_address_base,color_address_diff,1);
        q_line()
        # blank line
        q_line()
    }
    hunks++
}

# Print an address header at the beginning of a new block of differences.
function print_address(                                                 \
                       old, new, old_str, new_str, old_map, new_map){
    old_str = sprintf("0x%08x",old_cursor)
    new_str = sprintf("0x%08x",new_cursor)
    out_highlight(" "old_str," "new_str,color_address_base_underline,
                  color_address_diff_underline,1);
    q(" ----- ",color_bar_underline)
    out_highlight(new_str" ",old_str" ",color_address_base_underline,
                  color_address_diff_underline,1);
    q_line()
    # If there's an address mapping in effect for this region, indicate it.
    old_map = map_an_address(old_cursor)
    new_map = map_an_address(new_cursor)
    if (old_cursor != old_map || new_cursor != new_map){
        old_str = sprintf("0x%08x",old_map)
        new_str = sprintf("0x%08x",new_map)

        out_highlight(" "old_str," "new_str,color_address_deemph,
                      color_address_deemph_diff,1);
        q("  map  ", color_address_deemph)
        out_highlight(new_str" ",old_str" ",color_address_deemph,
                      color_address_deemph_diff,1);
        q_line()
    }
}

# Print one line of a diff block.  Takes two words formatted for
# display, compares and applies highlights, adds the status
# indicator ('<' and/or '>') and prints.  Optionally adds dittomarks
# to clarify long runs of identical word values, but only in changed lines.
function print_diff_line(old_word, new_word,
                     c, ccolor) {
    if(old_word == new_word){
        q(sprintf(" %s     %s ", old_word, new_word), color_bytes_unchanged)
        q_line()
    } else {
        if(ditto_active && old_ditto && old_ditto == old_word){
            out_highlight("     \" \"    "," "new_word,
                          color_bytes_oldchanged,color_bytes_oldchanged,0)
        }else{
            out_highlight(" "old_word," "new_word,
                          attributes_off,color_bytes_oldchanged,0)
        }
        c = "  !  "
        ccolor = color_bytes_changed
        if (old_word == "") {
            ccolor = color_bytes_newchanged
            c = "  >  "
        }
        if (new_word == ""){
            ccolor = color_bytes_oldchanged
            c = "  <  "
        }
        q(c,ccolor)
        if(ditto_active && new_ditto && new_ditto == new_word){
            out_highlight("    \" \"     ",old_word" ",
                          color_bytes_newchanged,color_bytes_newchanged,0);
        }else{
            out_highlight(new_word" ",old_word" ",attributes_off,color_bytes_newchanged,0);
        }
        q_line()
    }
    bytecount_old_word(old_word)
    bytecount_new_word(new_word)
    old_ditto = old_word
    new_ditto = new_word
    block_old_cursor = old_cursor
    block_new_cursor = new_cursor
    block_old_crc = old_crc
    block_new_crc = new_crc
}

function print_precontext(){
    while(context_count>0){
        context_count--
        print_diff_line(context_word[context_count],context_word[context_count])
    }
}



# Discard but count metrics for one line of a diff block; called for
# lines between blocks.  Takes two words formatted for display.
function discard_context_line(){
    if(context_count>0){
        context_count--
        bytecount_old_word(context_word[context_count])
        bytecount_new_word(context_word[context_count])
        old_ditto = ""
        new_ditto = ""
        new_block=1
    }
}

function discard_all_context(){
    # discard but count any pending pre-context
    while(context_count>0) discard_context_line()
}

function print_end(){
    print_address_footer()
    discard_all_context()
    print_address()
    if(crc_active){
        q(sprintf(" 0x%08x  crc  0x%08x ",
                  gnuify_crc32(old_crc, old_cursor),
                  gnuify_crc32(new_crc, new_cursor)),
          color_address_deemph)
        q_underline()
        q_line()
    }
    q(" ",color_address_base)
    q("-----------",color_bar)
    q(" END ",color_address_base)
    q("-----------",color_bar)
    q(" ",color_address_base)
    q_line()
    q_line()
    q_flush()
}

function print_new_block(\
                         i){
    # Do we need to print an address header?
    if (new_block) {
        # Print footer for preceding block.
        print_address_footer()
        print_address()
        new_block=0
    }
    # Print any pending pre-context
    print_precontext()
    # Mark need for trailing context before starting a new address block
    context_count= -context
}

# Takes a line of input in the original packed/overlapping input
# formatting, and returns a 4-byte word formatted for printing.
function format_word(line){
    if(line == ""){
        return line
    } else {
        return sprintf("%2s %2s %2s %2s",
                       substr(line,2,2),
                       substr(line,4,2),
                       substr(line,6,2),
                       substr(line,8,2))
    }
}

function right_justify(str, chars,
                      fill){
    for(fill = chars - length(str);fill>0;fill--)
        str = " "str
    return str
}

function left_justify(str, chars,
                       fill){
    for(fill = chars - length(str);fill>0;fill--)
        str = str" "
    return str
}

# Toplevel for line-by-line output handling; manages context, address
# output, crcs, and line formatting.
function submit_line(old_line, new_line,
                     i, old_word, new_word){
    old_word = format_word(old_line)
    new_word = format_word(new_line)
    if(old_word == new_word){
        # push the line into context or print it?
        if(context_count<0){
            # running out post-context, so print
            print_diff_line(old_word,new_word)
            context_count++
        } else {
            # already passed [context] identical lines, push to context queue
            for(i=context_count;i>0;i--) {
                context_word[i]=context_word[i-1]
            }
            context_word[0] = old_word
            context_count++
            if(context_count > context) {
                # Over limit; push a line out of the context
                discard_context_line()
            }
        }
    } else {
        # conditionally start a new block output
        print_new_block()
        # Flush/print requested words as needed
        print_diff_line(old_word, new_word)
    }
}

# Specialized version of submit_line + print_diff_line for redacted
# output.
function redact_lines(num_lines,
                      i){
    if(num_lines > 0){
        # conditionally start a new block output
        print_new_block()
        # output redaction
        q(" .. .. .. .. <<< ",color_bytes_oldchanged)
        if(num_lines==1){
            q(left_justify("1 line",12))
        }else{
            q(left_justify(sprintf("%d lines", num_lines),12))
        }
        q_line()
        # update CRC and printed byte count, must be done after
        # print_new_block()
        for(i = 0; i < num_lines; i++)
            bytecount_old_word(format_word(old_line[i]))
        block_old_cursor = old_cursor
        block_old_crc = old_crc
    }
}

# Specialized version of submit_line + print_diff_line for elided
# output.
function elide_lines(line, num_lines, old_or_new,
                       i){
    if(num_lines > 0){
        word = format_word(line)
        # conditionally start a new block output
        print_new_block()
        # output elided section
        if(old_or_new == "old"){
            out_highlight(" "word," ",attributes_off,color_bytes_oldchanged,0)
            q(" <<< ",color_bytes_oldchanged)
            if(num_lines==1){
                q(left_justify("1 line",12))
            }else{
                q(left_justify(sprintf("%d lines", num_lines),12))
            }
            # update CRC and counts, must be done after print_new_block()
            for(i = 0; i < num_lines; i++)
                bytecount_old_word(word)
        } else {
            if(num_lines==1){
                q(right_justify("1 line",12))
            }else{
                q(right_justify(sprintf("%d lines", num_lines),12))
            }
            q(" >>> ",color_bytes_newchanged)
            out_highlight(word" "," ",attributes_off,color_bytes_newchanged,0)
            # update CRC and printed byte count, must be done after
            # print_new_block()
            for(i = 0; i < num_lines; i++)
                bytecount_new_word(word)
        }
        q_line()
        block_old_cursor = old_cursor
        block_new_cursor = new_cursor
        block_old_crc = old_crc
        block_new_crc = new_crc
    }
}

# simple abs() function as there's no relaibly available built-in
function abs(v){
    if(v<0)v= -v
    return v
}

function push_old_line(line){
    old_line[old_count++]=line
    old_advance--
}

function push_new_line(line){
    new_line[new_count++]=line
    new_advance--
}

function remove_old_lines(num,
                          j){
    # More concerned about being correct than
    # efficient right now, so doing it the simple way and just
    # shifting the line buffers.
    old_count -= num
    for(j=0; j<old_count; j++) old_line[j]=old_line[j+num]
}

function remove_new_lines(num,
                      j){
    # More concerned about being correct than
    # efficient right now, so doing it the simple way and just
    # shifting the line buffers.
    new_count -= num
    for(j=0; j<new_count; j++) new_line[j]=new_line[j+num]
}

# Given a subsection, determine if repeated lines need should be
# elided for clarity.  Elide only if pure insertion, deletion, or both
# sides of the diff are repeats.  Ditto marking is handled elsewhere.
function elide_split(old_end, new_end,
                        i, j, old_pos, new_pos){
    old_pos=0
    new_pos=0
    while(old_pos < old_end || new_pos < new_end){
        # match lines are never elided; they're likely to be
        # part of context.
        if(old_pos < old_end && new_pos < new_end &&
           substr(old_line[old_pos],2,8) == substr(new_line[new_pos],2,8)){
            submit_line(old_line[old_pos], new_line[new_pos])
            old_pos++
            new_pos++
        } else {
            for(i=old_pos+1; i<old_end; i++){
                if(substr(old_line[old_pos],2,8) != substr(old_line[i],2,8)) break
            }
            for(j=new_pos+1; j<new_end; j++){
                if(substr(new_line[new_pos],2,8) != substr(new_line[j],2,8)) break
            }
            i-=old_pos
            j-=new_pos
            if(i>elision_thresh && j>elision_thresh){
                # both sides have sufficient repeats to bother eliding.
                elide_lines(old_line[old_pos],i,"old")
                elide_lines(new_line[new_pos],j,"new")
                old_pos+=i
                new_pos+=j
                continue
            }
            # Only elide as much as would shorten output
            if(i>old_end-old_pos-new_end+new_pos){
                i = old_end-old_pos-new_end+new_pos
            }
            if(j>new_end-new_pos-old_end+old_pos){
                j = new_end-new_pos-old_end+old_pos
            }
            if(i>elision_thresh){
                # deletion
                elide_lines(old_line[old_pos],i,"old")
                old_pos+=i
                continue
            }
            if(j>elision_thresh){
                # insertion
                elide_lines(new_line[new_pos],j,"new")
                new_pos+=j
                continue
            }
            if(old_pos<old_end && new_pos<new_end){
                submit_line(old_line[old_pos], new_line[new_pos])
                old_pos++
                new_pos++
                continue
            }
            if(old_pos<old_end){
                submit_line(old_line[old_pos],"")
                old_pos++
                continue
            }
            submit_line("",new_line[new_pos])
            new_pos++
        }
    }
}

function output_split(old_end, new_end,
                     i, j, old_pos, new_pos){
    # search exact word match up from bottom
    old_pos=old_end
    new_pos=new_end
    while(old_pos>0 && new_pos>0){
        if(substr(old_line[old_pos-1],2,8)!=            \
           substr(new_line[new_pos-1],2,8))break;
        old_pos--
        new_pos--
    }

    # When redacting input, we only worry about the mid lines of the
    # split.  Initial leading exact matches are stripped away by
    # forward match.  We shouldn't have any trailing exact matches at
    # the bottom of the split, because context is normally 0.  If
    # context is not 0 then that's a user override, so don't redact it.
    if (redact_active) {
        redact_lines(old_pos)
        if(elision_active){
            elide_split(0,new_pos)
        }else{
            for(j=0; j<new_pos; j++)
                submit_line("",new_line[j])
        }
    } else {
        if(elision_active){
            elide_split(old_pos,new_pos)
        }else{
            for(i=0; i<old_pos && i<new_pos; i++)
                submit_line(old_line[i], new_line[i])
            for(j=i; j<old_pos; j++)
                submit_line(old_line[j],"")
            for(j=i; j<new_pos; j++)
                submit_line("",new_line[j])
        }
    }

    # now push the exact bottom matches; don't redact or elide.
    while(old_pos<old_end && new_pos<new_end){
        submit_line(old_line[old_pos], new_line[new_pos])
        old_pos++
        new_pos++
    }
    # done
    remove_old_lines(old_end)
    remove_new_lines(new_end)
}

function match_forward(old_end, new_end,
                       i){
    # Excluding words from the initial exact natching through diff
    # will result in diff sections that begin with or consist
    # entirely of lines that actually do match.  Start by
    # submitting these exact matches (which will handle any
    # outputting needed).  Similarly, the recursive parsing breaks
    # up regions by exact match, and those exact matches will need
    # to be pushed out here as well.
    for(i=0; i<old_end && i<new_end; i++){
        if(substr(old_line[i],2,8) != substr(new_line[i],2,8))break
        submit_line(old_line[i],new_line[i])
    }

    # Submitted lines need to be removed from the old and
    # new line lists.
    remove_old_lines(i)
    remove_new_lines(i)
    return i
}

function match_search(old_end, new_end, pos_return,
                      i, j){
    # search by increasing offset
    for (j=0; j<old_end || j<new_end; j++) {
        # common overlap loop
        for(i=0; i<new_end-j && i<old_end-j; i++){
            if(old_line[i] == new_line[i+j]) {
                pos_return["old"] = i
                pos_return["new"] = i+j
                pos_return["off"] = -j
                return
            }
            if(old_line[i+j] == new_line[i]) {
                pos_return["old"] = i+j
                pos_return["new"] = i
                pos_return["off"] = j
                return
            }
        }
        # more negative offset to search?
        while(i<new_end-j && i<old_end){
            if(old_line[i] == new_line[i+j]){
                pos_return["old"] = i
                pos_return["new"] = i+j
                pos_return["off"] = -j
                return
            }
            i++
        }
        # more positive offset to search?
        while(i<old_end-j && i<new_end){
            if(old_line[i+j] == new_line[i]){
                pos_return["old"] = i+j
                pos_return["new"] = i
                pos_return["off"] = j
                return
            }
            i++
        }
    }
    pos_return["old"] = old_end
    pos_return["new"] = new_end
    pos_return["off"] = old_end - new_end
}

function trim_for_subsearch(old_end, new_end, len,
                                   i){
    for(i=0; i<old_end; i++) old_line[i] = substr(old_line[i],1,len)
    for(i=0; i<new_end; i++) new_line[i] = substr(new_line[i],1,len)
}

function set_exclusions(old_end,
                        i){
    for(i=0; i<old_end; i++)
        old_line[i]=gensub(/(w)(00000000|ffffffff)/,"x\\2","g",old_line[i])
}

function clear_exclusions(old_end,
                          i){
    for(i=0; i<old_end; i++) gsub(/x/,"w",old_line[i])
}

function weak_split(old_end, new_end, threshold,
                    i, j, pos){
    if(threshold < match_words_min){
        clear_exclusions(old_end)
        output_split(old_end, new_end)
    }else{
        # Rather than complicating match with substr, perform it up front.
        trim_for_subsearch(old_end, new_end, threshold*9)

        while (new_end>0 || old_end>0) {
            i = match_forward(old_end, new_end)
            # update our own local subset end count
            old_end -= i
            new_end -= i
            # Do nothing further if that was the whole section.
            if(old_end==0 && new_end==0) break;

            # Look forward for exact matches; we split diff parsing at
            # that point.
            match_search(old_end, new_end, pos)

            # recurse, match or no.
            weak_split(pos["old"], pos["new"], threshold-1)

            # The weak_split call will always consume the entire region
            # passed to it.
            old_end -= pos["old"]
            new_end -= pos["new"]
        }
    }
}

# Successively break up initial region into exact matches searched by
# increasing offset.
function strong_split(old_end, new_end,
                      i, j, pos){
    while (new_end>0 || old_end>0) {
        i = match_forward(old_end, new_end)
        # update our own local subset end count
        old_end -= i
        new_end -= i
        # Do nothing further if that was the whole section.
        if(old_end==0 && new_end==0) break

        # Look forward for exact matches; we split diff parsing at
        # that point.
        match_search(old_end, new_end, pos)

        # If no exact matches, our region is not bookmarked by
        # initial matches, and so we don't have enough information
        # to make a good submatch.  Return.
        if(pos["old"] == old_end) break

        # if no currently active match horizon point, set it
        if(!advance_active){
            advance_active = 1
            old_advance = horizon
            new_advance = horizon
        }
        if(old_advance>0 || new_advance>0) return
        old_advance = 0
        new_advance = 0
        advance_active = 0

        # Check the buffered horizon against the offset.  We want
        # sufficient lookahead to make strong, low-offset matches
        # before doing lots of subdivision.  Thus we want to avoid
        # making immediate high-offset matches that would prevent
        # better low-offset matches in the future.

        # Heuristic is to make sure that there's sufficient buffer
        # that the matching positions from above would still land in
        # the existing the buffer if the offset sign is flipped.

        if(!diff_eof){
            new_advance = pos["old"] + horizon - new_end + pos["off"]*2
            old_advance = pos["new"] + horizon - old_end - pos["off"]*2
            if(new_advance > 0 || old_advance > 0){
                advance_active = 1
                return
            }
        }

        # Recurse to subdivide
        set_exclusions(old_end)
        weak_split(pos["old"], pos["new"], match_words_max-1)

        # Upon returning, we've parsed, output, and removed the
        # regions that previously stretched from [0 .. old_pos)
        # and [0 .. newpos). Update our own subset and iterate.
        old_end -= pos["old"]
        new_end -= pos["new"]
    }
}

function list_map_error(i, j,
                        k, str){
    err("       Requested mapping ranges:")
    for(k=0; k < address_maps; k++) {
        if (k+1 < address_maps) {
            str = sprintf("       %d) src: [0x%08x..0x%08x) -> "        \
                          "dst [0x%08x..0x%08x)",k,
                          address_map_src[k],
                          address_map_src[k+1],
                          address_map_dst[k],
                          address_map_dst[k] +                          \
                          address_map_src[k+1] - address_map_src[k])
        } else {
            str = sprintf("       %d) src: [0x%08x..   EOF    ] -> "    \
                          "dst [0x%08x..   EOF    ]",k,
                          address_map_src[k],
                          address_map_dst[k])
        }
        if (k==i || k==j) {
            str=str" <<<"
        }
        err(str)
    }
    err("")
}

function sanity_check_maps(                                             \
                           i, j, k, lenA, startA, endA, len, start, end){
    for (i=0; i < address_maps-1; i++) {
        lenA = address_map_src[i+1] - address_map_src[i]
        startA = address_map_dst[i]
        endA   = address_map_dst[i] + lenA
        for (j=i+1; j < address_maps; j++) {
            if (j+1 < address_maps) {
                len = address_map_src[j+1] - address_map_src[j]
                start = address_map_dst[j]
                end   = address_map_dst[j] + len
                if (start < startA) start = startA
                if (end > endA) end = endA
                if (start < end) {
                    err(sprintf("ERROR: Mapped destination address"     \
                                " conflict from 0x%08x to 0x%08x",
                                start, end))
                    list_map_error(i,j)
                    exit(1)
                }
            } else {
                start = address_map_dst[j]
                end = start + 1
                if (start < startA) start = startA
                if (end > endA) end = endA
                if (start < end) {
                    err(sprintf("ERROR: Mapped destination address"     \
                                " conflict beginning at 0x%08x",
                                start))
                    list_map_error(i,j)
                    exit(1)
                }
                if (start < endA) {
                    err("ERROR: Possible destination address"           \
                        " conflict depending on length of input.")
                    err(sprintf("       Final mapping destination may"  \
                                " extend into mapping %d.",i))
                    list_map_error(i,j)
                    exit(1)
                }
            }
        }
    }
}

# Internally, address mapping regions are simple src/dest
# pairs. Regions are ordered and each region stretches to the
# next so that there are no holes.
function add_map(dst, src, len,
                 i, j, k, src_prev, dst_prev){
    if (address_maps == 0) {
        address_map_src[0] = 0
        address_map_dst[0] = 0
        address_maps = 1;
    }
    dst = strtonum(dst)
    src = strtonum(src)
    # find insertion point for start of map
    for(i=0; i < address_maps; i++) {
        if(address_map_src[i] >= src) break
    }
    if(len == ""){
        # unbounded address map; add one entry from
        # src/dest to end of file, replacing any later entries
        address_map_src[i] = src
        address_map_dst[i] = dst
        address_maps = i+1;
    } else {
        len = strtonum(len)
        # bounded address map; add two entries, one that enters the
        # map and one that exits it, potentially to some previously
        # specified map that is only being partially replaced.

        # find where this map ends.  loop below saves mapping entry
        # we're cutting/replacing.
        src_prev = 0
        dst_prev = 0
        for(j=0; j < address_maps; j++) {
            if(address_map_src[j] > src+len) break
            src_prev = address_map_src[j];
            dst_prev = address_map_dst[j];
        }
        # we'll insert two entries and delete i through j exclusive;
        # expand/contract list past i as needed
        if(2 > j-i) {
            # expand
            for(k=address_maps-1; k>=i; k--){
                address_map_src[k+2-j+i] = address_map_src[k];
                address_map_dst[k+2-j+i] = address_map_dst[k];
            }
        } else if (2 < j-i) {
            #contract
            for(k=i+2; k<address_maps; k++){
                address_map_src[k] = address_map_src[k+j-i-2];
                address_map_dst[k] = address_map_dst[k+j-i-2];
            }
        }
        address_maps += 2-j+i
        address_map_src[i+1] = src + len
        address_map_dst[i+1] = (src + len - src_prev) + dst_prev
        address_map_src[i] = src
        address_map_dst[i] = dst
    }
}

function setup_color() {
    # fetch terminal info if we can
    if(INFOCMP){
        RS="^$"
        if ((cmd = INFOCMP" -0") | getline) {
            term = $0
            close(cmd)
        }
        RS="\n"
    }
    if (term ~ /colors/) {
        # is underline available?
        # is invisible mode available?
        if (term ~ /smul=/ && term ~ /invis=/) {
            # Invis means we can hide the '---' separators, so make
            # things prettier with an underline.
            attribute_underline = ";4"
            color_bar = "\033[0;8m"
            color_bar_underline = "\033[0;8;4m"
            color_address_base = "\033[0m"
            color_address_base_underline = "\033[0;4m"
            # is bold or rev available?
            if (term ~ /bold=/) {
                color_address_diff = "\033[0;1m"
                color_address_diff_underline = "\033[0;1;4m"
            } else if (term ~ /rev=/) {
                color_address_diff = "\033[0;7m"
                color_address_diff_underline = "\033[0;7;4m"
            } else {
                color_address_diff = "\033[0m"
                color_address_diff_underline = "\033[0;4m"
            }
        }else{
            # can't hide the ---, so don't use underlines.
            attribute_underline = ""
            color_bar = "\033[0m"
            color_bar_underline = "\033[0m"
            color_address_base = "\033[0m"
            color_address_base_underline = "\033[0m"
            # is bold or rev available?
            if (term ~ /bold=/) {
                color_address_diff = "\033[0;1m"
                color_address_diff_underline = "\033[0;1m"
            } else if (term ~ /rev=/) {
                color_address_diff = "\033[0;7m"
                color_address_diff_underline = "\033[0;7m"
            } else {
                color_address_diff = "\033[0m"
                color_address_diff_underline = "\033[0m"
            }
        }
        # is dim available?
        if (term ~ /dim=/) {
            color_address_deemph = "\033[0;2m"
            # is bold available?
            if (term ~ /bold=/) {
                color_address_deemph_diff = "\033[0;1;2m"
            }else{
                color_address_deemph_diff = "\033[0m"
            }
            color_bytes_unchanged = "\033[0;2m"
        }else{
            color_address_deemph = "\033[0m"
            # is bold available?
            if (term ~ /bold=/) {
                color_address_deemph_diff = "\033[0;1m"
            }else{
                color_address_deemph_diff = "\033[0m"
            }
            color_bytes_unchanged = "\033[0m"
        }
        # can we bold bright color changes?
        if (term ~ /bold=/) {
            color_bytes_oldchanged = "\033[0;31;1m"
            color_bytes_newchanged = "\033[0;32;1m"
            color_bytes_changed = "\033[0;1m"
        }else{
            color_bytes_oldchanged = "\033[0;31m"
            color_bytes_newchanged = "\033[0;32m"
            color_bytes_changed = "\033[0m"
        }
        attributes_off = "\033[0m"
    }
}

function disable_color(){
    color_address_base=""
    color_address_base_underline=""
    color_address_diff=""
    color_address_diff_underline=""
    color_address_deemph=""
    color_address_deemph_diff=""
    color_bytes_unchanged=""
    color_bytes_oldchanged=""
    color_bytes_newchanged=""
    color_bytes_changed=""
    color_bar=""
    color_bar_underline=""
    attribute_underline = ""
    attributes_off=""
}

function stdout_usage(\
                      save_dev){
    save_dev=err_device
    err_device="/dev/stdout"
    usage()
    err_device=save_dev
}

function usage(){
    err("")
    err("diff32 : A 'diff'-style comparison tool for raw 32 bit binaries")
    err("")
    err("USAGE  : diff32 [OPTIONS] fileA.bin fileB.bin")
    err("")
    err("OPTIONS:")
    err("")
    err("  -c, --context=NUM")
    err("")
    err("     Include NUM lines of copied context before and after changes.")
    err("     Minimum value is 0, maximum is 16.  Default is 3.")
    err("")
    err("  -d, --dittomarks")
    err("")
    err("     Mark consecutive identical words in fileA or fileB with ditto")
    err("     marks (\" \"), rather than printing the literal values, in")
    err("     order to highlight runs of identical values.  Only lines where")
    err("     the fileA and fileB sides differ will be marked; context and")
    err("     other identical matching lines will not be marked.")
    err("")
    err("  -D, --no-dittomarks")
    err("")
    err("     Disable dittomarking.")
    err("")
    err("  -e, --elide=NUM")
    err("")
    err("     Perform output elision when it will shorten the output by NUM")
    err("     lines or more. Elision replaces runs of identical entries on the")
    err("     left or right side with a single line indicating the repeated")
    err("     word and number of times the word is repeated. Default NUM is 4.")
    err("")
    err("  -E, --no-elision")
    err("")
    err("     Disable elision.")
    err("")
    err("  -h, --help")
    err("")
    err("     Output this help message and exit.")
    err("")
    err("  -l, --minimum-match-length=NUM")
    err("")
    err("     Sets the minimum length in words of a match when performing")
    err("     subdivision of large regions.  NUM may be 1 through 32 (default")
    err("     is 1 words) and must be less than or equal to the initial")
    err("     match length.")
    err("")
    err("  -L, --initial-match-length=NUM")
    err("")
    err("     Sets the required match length in words when doing initial")
    err("     matching of large regions. NUM may be 1 through 32 (default")
    err("     is 8 lines/words) and must be greater than or equal to the")
    err("     minimum match length.")
    err("")
    err("  -m, --map=DESTINATION[,SOURCE[,LENGTH]]")
    err("")
    err("     Map displayed input byte range of LENGTH bytes starting at")
    err("     SOURCE byte offset to the range beginning at DESTINATION.  -m")
    err("     only affects displayed addresses, not match or output order.")
    err("     Omitting LENGTH extends range to the end of the file.  Omitting")
    err("     both SOURCE and LENGTH maps the entire input. More than one")
    err("     range may be specified. Later overlapping input ranges override")
    err("     earlier ranges. Final destination ranges may not overlap. Values")
    err("     may be decimal, octal (leading 0) or hexadecimal (leading 0x).")
    err("")
    err("  -n, --no-pager")
    err("")
    err("     Do not use a pager or format/color output for display on a")
    err("     terminal.  This overrides the default behavior of using a pager")
    err("     and colorized output when stdout is attatched to a terminal.")
    err("")
    err("  -p, --pager")
    err("")
    err("     Use a pager (default is \"less\") and colorize output (default")
    err("     behavior when stdout is attatched to a terminal).")
    err("")
    err("  -r, --redact-original")
    err("")
    err("     Redact fileA's words from the diff32 output by emitting changes")
    err("     as block deletions from fileA marked '.. .. .. .. <<<', followed")
    err("     by insertions from fileB. Context is set to zero, but may be")
    err("     over-ridden by following with -c LINES.  Redaction is intended to")
    err("     minimize the amount of information from fileA included in output.")
    err("")
    err("  -v, --version")
    err("")
    err("     Output version and exit.")
    err("")
    err("  -z, --extend-horizon=NUM")
    err("")
    err("     Add NUM additional words to the computed lookahead horizon when")
    err("     searching for initial matches with the lowest possible offsets.")
    err("     NUM may be between zero (disabling lookahead) and 4096. Higher")
    err("     values may produce better output at the cost of greatly increased")
    err("     computation time.  The default value is 32.")
    err("")
    err("  --color")
    err("")
    err("     Colorize the output.  Default behavior when using the default")
    err("     pager or outputting directly to a tty.")
    err("")
    err("  --no-color")
    err("")
    err("     Do not colorize the output.")
    err("")
    err("  --crc")
    err("")
    err("     Add running CRC32 checksum of both files and each output hunk")
    err("     to hunk and file footers. --crc is default behavior when stdout")
    err("     is not attached to a terminal. -n and -r imply also --crc.")
    err("")
    err("  --no-crc")
    err("")
    err("     Disable CRC32 checksumming. -p implies --no-crc.")
    err("")
    err("DETAILS:")
    err("")
    err("     diff32 is a gawk script that wraps the standard diff utility")
    err("     to produce a human- or machine-readable side-by-side text summary")
    err("     of differences between two raw 32-bit binary files. diff32 ")
    err("     searches for changes, insertions, and deletions. It can be used")
    err("     to manually inspect differences between two binary files, or as")
    err("     a automated format of binary patch interchange.")
    err("")
    err("EXAMPLES:")
    err("")
    err("  diff32 mips_binary1.bin mips_binary2.bin")
    err("")
    err("     Produce a colorized summary of the differences in binary files")
    err("     mips_binary1.bin and mips_binary2.bin, presented on the terminal")
    err("     one page at a time using the 'less' utility.")
    err("")
    err("  diff32 -r secret1 secret2")
    err("")
    err("     Produce a patch that specifies how to convert binary file secret1")
    err("     to file secret2 without including byte values from secret1. Hunk")
    err("     match verification is performed by location and checksum.")
    err("")
    err("  diff32 -m 0x600 -m 0,0x200,0x200 -m 0x400,0,0x200 overlay1 overlay2")
    err("")
    err("     View a paged/colorized difference summary between overlay1 and")
    err("     overlay2 adding map header entries reflecting where different")
    err("     portions of the file are mapped.  Maps can make diff32 output")
    err("     easier to compare to live memory locations when using tools such")
    err("     as Ghidra or IDA with overlays and compacted binaries.")
    err("")
    err("AUTHOR:")
    err("")
    err("     Written by Monty Montgomery <monty@xiph.org>")
    err("     This is free software: you are free to change and redistribute")
    err("     it.  There is NO WARRANTY, to the extent permitted by law.")
    err("")
    err("SEE ALSO:")
    err("")
    err("  patch32(1), diff(1), cmp(1), xdelta(1), gawk(1), less(1), infocmp(1)")
    err("")
}

function version () {
    q("  diff32 version 0.9.0, plus:")
    q_line()
    if ((cmd = "/usr/bin/gawk --version 2>/dev/null") | getline) {
        q("    "$0)
        close(cmd)
        q_line()
    }
    if ((cmd = DIFF" --version 2>/dev/null") | getline) {
        q("    "$0)
        close(cmd)
        q_line()
    }
    if ((cmd = LESS" --version 2>/dev/null") | getline) {
        q("    "$0)
        close(cmd)
        q_line()
    }
    if ((cmd = INFOCMP" -V 2>/dev/null") | getline) {
        q("    "$0)
        close(cmd)
        q_line()
    }
    q_line()
    q_line()
}

function opterr(msg){
    err("")
    err("diff32: "msg"")
    err("        See man page or diff32 --help for more information.")
    err("")
    close("/dev/stdout")
    exit(1)
}

function getopts(argc, argv,
                 i, j, options_done, options, argument, pos){
    options_done = 0;
    for(i=1; i<argc; i++){
        option = ""
        delete argument
        if (!options_done){
            if (argv[i] == "--") {
                options_done = 1
            } else {
                if (substr(argv[i],1,2) == "--"){
                    pos = index(argv[i],"=")
                    if (pos>0) {
                        option = substr(argv[i],3,pos-3)
                        split(substr(argv[i],pos+1),argument,",")
                    } else {
                        option = substr(argv[i],3)
                    }
                } else if (substr(argv[i],1,1) == "-"){
                    if(length(argv[i])>2){
                        opterr("Error parsing command line argument.")
                    }
                    option = substr(argv[i],2)
                    split(argv[i+1],argument,",")
                } else {
                    if (fileA == "") {
                        fileA = argv[i]
                        continue
                    } else if (fileB =="") {
                        fileB = argv[i]
                        continue
                    } else {
                        opterr("Too many files specified on command line.")
                    }
                }
                if (option == "c" || option == "e" || option=="l" || option=="L" ||
                    option== "m" || option == "z"){
                    i++ # advance past argument
                }
                if (option == "c" || option == "context"){
                    if (argument[1] == "" || argument[2] != "") {
                        opterr("Context takes a single argument.")
                    }
                    context = strtonum(argument[1]);
                    if(context < 0 || context > 16){
                        opterr("Context argument must be in the range 0..16.")
                    }
                }else if (option == "d" || option == "dittomarks"){
                    ditto_active = 1
                }else if (option == "D" || option == "no-dittomarks"){
                    ditto_active = 0
                } else if (option == "e" || option == "elide") {
                    if (argument[1] == "" || argument[2] != "") {
                        opterr("Elide takes a single argument.")
                    }
                    elision_active = 1
                    elision_thresh = strtonum(argument[1])+1;
                    if(elision_thresh < 2){
                        opterr("Elision argument must be greater than 0.")
                    }
                }else if (option == "E" || option == "no-elision"){
                    elision_active = 0
                } else if (option == "r" || option == "redact-original") {
                    redact_active = 1
                    elision_active = 1
                    elision_thresh = 4
                    ditto_active = 1
                    crc_active = 1
                    context = 0
                } else if (option == "l" || option == "minimum-match-length") {
                    if (argument[1] == "" || argument[2] != "") {
                        opterr("Minimum match length takes a single argument.")
                    }
                    match_words_min = strtonum(argument[1]);
                    if(match_words_min < 1 || match_words_min>32){
                        opterr("Minimum match length must be in the range 1..32.")
                    }
                } else if (option == "L" || option == "initial-match-length") {
                    if (argument[1] == "" || argument[2] != "") {
                        opterr("Initial match length takes a single argument.")
                    }
                    match_words_max = strtonum(argument[1]);
                    if(match_words_max < 1 || match_words_max>32){
                        opterr("Initial match length must be in the range 1..32.")
                    }
                } else if (option == "h" || option == "help") {
                    stdout_usage()
                    exit(0)
                } else if (option == "m" || option == "map") {
                    if (argument[1] == "" || argument[4] != "") {
                        opterr("Map option takes one to three comma-separated arguments.")
                    }
                    add_map(argument[1],argument[2],argument[3])
                } else if (option == "n" || option == "no-pager") {
                    # the actual paging setup is handled by the shell wrapper
                    disable_color()
                    crc_active = 1
                } else if (option == "p" || option == "pager") {
                    # the actual paging setup is handled by the shell wrapper
                    setup_color()
                    if (!redact_active) crc_active = 0
                } else if (option == "v" || option == "version") {
                    version()
                    exit(0)
                } else if (option == "z" || option == "extend-horizon"){
                    if (argument[1] == "" || argument[2] != "") {
                        opterr("Horizon option takes a single argument.")
                    }
                    horizon = strtonum(argument[1]);
                    if(horizon < 0 || horizon > 4096){
                        opterr("Horizon argument must be in the range 0..4096.")
                    }
                } else if (option == "color") {
                    setup_color()
                } else if (option == "no-color") {
                    disable_color()
                } else if (option == "crc") {
                    crc_active = 1
                } else if (option == "no-crc") {
                    crc_active = 0
                } else {
                    opterr("Unknown arguemnt on command line.")
                }
            }
        } else {
            if (fileA == "") {
                fileA = argv[i]
            } else if (fileB =="") {
                fileB = argv[i]
            } else {
                opterr("Too many files specified on command line.")
            }
        }
    }

    if(fileA == "" || fileB == ""){
        opterr("Missing input file(s).")
    }

    if(match_words_min>match_words_max){
        opterr("Minimum match length must be less than or equal to initial match length.")
    }
    sanity_check_maps()
}

function output_maps(\
                     k){
    for(k=0; k < address_maps; k++) {
        q(sprintf("MAP: 0x%08x -> 0x%08x",
                    address_map_src[k],
                    address_map_dst[k]))
        q_line()
    }
    if(address_maps) q_line()
}

function find_util(path, envvar, report,
                   cmd){
    if(ENVIRON[envvar])path = ENVIRON[envvar]
    cmd = "command -v "path
    cmd|getline
    close(cmd)
    if(!$0 && report) err("diff32: Can't find '"path"' utility in the path.")
    return $0
}

BEGIN {
    # arguments
    context = 3
    swap = 0
    redact_active = 0
    crc_active=1
    ditto_active=1
    elision_active=1
    elision_thresh=5
    match_words_min = 1
    match_words_max = 8
    horizon = 32

    # global state variables
    old_cursor=0
    new_cursor=0
    old_count=0
    new_count=0
    old_advance=0
    new_advance=0
    old_crc=0
    new_crc=0
    advance_active=0
    diff_eof=0
    context_count=0
    new_block=1
    hunks=0
    address_maps=0
    err_device="/dev/stderr"

    DIFF = find_util("diff", "DIFFPROG", 1)
    LESS = find_util("less", "PAGER", 1)
    INFOCMP = find_util("infocmp", "INFOCMP", 0)
    getopts(ARGC, ARGV)
    if(crc_active)init_crc()

    # Convert binary input to undecorated hexadecimal ASCII.
    # This outputs a line per word, however each line consists of the
    # current word and the previous match_words_max-1 words as well.
    # This way we match on multiple words but with granularity.
    textify_cmd="LC_ALL=C /usr/bin/gawk '                               \
        BEGIN {\n                                                       \
            BINMODE = 3\n                                               \
            RS = \"[\\0-\\xff]{4}\"\n                                   \
            for(i=0;i<256;i++){\n                                       \
                f=sprintf(\"%c\",i)\n                                   \
                t=sprintf(\"%02x\",i)\n                                 \
                tohex[f]=t\n                                            \
            }\n                                                         \
        }\n                                                             \
        {\n                                                             \
            if(RT){\n                                                   \
                # normal case: grabbed four bytes\n                     \
                word = \"\"tohex[substr(RT,1,1)]\n                      \
                for(i=2;i<=4;i++) word = word\"\"tohex[substr(RT,i,1)]\n \
                line = \"w\"word\"\"substr(line,1,"match_words_max"*9-9)\n \
                print line\n                                            \
            }else{\n                                                    \
                # error case: should only happen if EOF happens\n       \
                # before a full 4 bytes\n                               \
                l = length($0)\n                                        \
                if(l<1 || l>3) exit(1)\n                                \
                word = \"\"tohex[substr($0,1,1)]\n                      \
                for(i=2;i<=l;i++) word = word\"\"tohex[substr($0,i,1)]\n \
                for(i;i<=4;i++) word = word\"  \"\n                     \
                line = \"w\"word\"\"substr(line,1,"match_words_max"*9-9)\n \
                print line\n                                            \
                exit(0)\n                                               \
           }                                                            \
        }'"
    diff_cmd=DIFF" "                                                    \
        "--old-line-format=$'< %l\n' "                                  \
        "--new-line-format=$'> %l\n' "                                  \
        "--unchanged-line-format=$'= %l\n' "                            \
        "-- "                                                           \
        "<("textify_cmd" \""fileA"\") "                                 \
        "<("textify_cmd" \""fileB"\") "
    output_maps()
    q("")
    while(!ERRNO && (diff_cmd | getline) > 0){
        line = $2
        if ($1=="="){
            push_old_line(line)
            push_new_line(line)
            strong_split(old_count, new_count)
        } else if ($1=="<") {
            push_old_line(line)
        } else if ($1==">") {
            push_new_line(line)
        }
    }
    diff_eof = 1
    # flush each stage of the diff handling pipeline
    strong_split(old_count, new_count)
    output_split(old_count, new_count)
    print_end()
    close(diff_cmd)
    close("/dev/stdout")
}

############################ diff32 gawk script ends ############################
#EOF
############################ back to the bash wrapper ###########################

_interrupt() {
  # Immediate kill 0 won't do what we want; it kills us too.
  # The pager must fully exit first.
  kill -INT $pager_pid
  wait $pager_pid
  # now kill 0 will do what we want
  kill -TERM 0
}

# default pager utility and options if not locally set
if [ -z "${PAGER}" ]; then
  export PAGER="less -R -K -M -X -F"
fi

# default diff utility and options if not locally set
if [ -z "${DIFFPROG}" ]; then
  export DIFFPROG="diff"
fi

# Test for interactive terminal and pager executable;
# if both present, default to using the configured pager.
[[ ! ( -t 1 && -x $(command -v $PAGER)) ]]
use_pager=$?

# Allow user to override default pager use.
# Scan arguments without clobbering them.
args=( "$@" )
while test $# -gt 0
do
    case "$1" in
        -p|--pager)
          use_pager=1
            ;;
        -n|--no-pager|-v|--version|-h|--help)
          use_pager=0
            ;;
    esac
    shift
done

if [ $use_pager == 1 ]; then
  ####################### pager case ############################
  # exec script, get output fd and pid.
  exec {diff32_fd}< <(gawk -f - -- "--pager" "${args[@]}" <&$script_fd) ; script_pid=$!
  # Trap interrupts before starting pager.
  trap _interrupt INT
  # Connect pager to script, get pager fd.
  $PAGER $PAGER_ARGS <&$diff32_fd & pager_pid=$!
  # Gate on the pager.
  wait $pager_pid
  # Done. Issue a kill to clean up children if pager quit before
  # diffing completed, and script didn't notice for some reason
  # (it should have, but might be stuck for some other reason).
  trap '' INT
  kill -INT 0
else
  ##################### non-pager case ##########################
  # run script.
  gawk -f - -- "${args[@]}" <&$script_fd
fi
