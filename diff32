#!/bin/sh

########################### diff32 bash paging wrapper ##########################
# Implements process/pipe/signal handling for use of a default pager with the
# diff32 gawk script. gawk doesn't offer any signal handling, thus this wrapper.
#
# We want ^C (SIGINT) to interrupt any in-progress/runaway computation but also
# cleanly exit a pager.  The pager must exit first, else the terminal gets
# clobbered by out-of-order cleanup.
#
# The wrapper also makes sure ^C really shuts down everything. If gawk gets hung
# in a loop or due to a bug, it won't notice that stdout/stderr simply went away.
# After the pager exits, the interrupt handler issues a kill 0.
#################### bash script continues after gawk section ###################

exec {script_fd}<<'#EOF'

############################### diff32 gawk script ##############################
#!/usr/bin/gawk -E   # Unnecessary, seems clearer to include it.

# Line-buffered program data output.  This queues pieces of a line (or
# lines really) to be explicitly flushed.  Optional argument sets the
# passed ANSI escape attributes, but only if not already set to the
# same string.
function q(string, attribute){
    if (output_q_lineready) q_flush()
    if (!attribute) attribute = attributes_off
    if (current_q_attribute != attribute) {
        output_q_buffer = output_q_buffer""attribute
        current_q_attribute = attribute
    }
    output_q_buffer = output_q_buffer""string
}

# underlines the text present in the line buffer, assuming
# terminal supports the operation. Cosmetic pretty-print.
function q_underline(){
    if(attribute_underline){
        # quick and dirty; 'm' only occurs in output when in ANSI escapes
        gsub("m",";4m",output_q_buffer)
        output_q_buffer = "\033[4m"output_q_buffer
    }
}

function q_line(){
    if (output_q_lineready) q_flush()
    if (current_q_attribute && current_q_attribute != attributes_off){
        output_q_buffer = output_q_buffer""attributes_off
        current_q_attribute = attributes_off
    }
    output_q_buffer = output_q_buffer"\n"
    output_q_lineready = 1
}

function q_flush(){
    printf output_q_buffer
    output_q_lineready = 0
    output_q_buffer = ""
}

# Program error output
function err(string){
    print string > err_dev
}

# helper function to print the input, optionally colorizing the
# nibbles that match the comparison input to_compare using the escape
# sequence 'off', and the nibbles that do not match with 'on'.  'lock'
# is nonzero if a color change to 'on' should persist for the rest of
# the string regardless of match; this is used to highlight address
# differences.
function out_highlight(to_print, to_compare, off_color, on_color, lock,
                       current, a, b, c, i){
    if (to_print == "") {
        to_print = "           "
    }
    if (to_compare == ""){
        to_compare = "           "
    }
    c=off_color
    for(i=1; i<=length(to_print); i++){
        a = substr(to_print,i,1)
        b = substr(to_compare,i,1)
        if(a != " "){
            if (a != b){
                c = on_color
            } else {
                if (!lock) c=off_color
            }
        }
        q(a,c)
    }
}

# Run an absolute address offset from beginning-of-file through
# the user-supplied maps to arrive at a display address.
function map_an_address(addr,
                        i){
    for (i=0; i<address_maps; i++) {
        if (address_map_src[i] <= addr) {
            addr = address_map_dst[i] + addr - address_map_src[i]
            break
        }
    }
    return addr
}

# Print an address header at the beginning of a new block of differences.
function print_address(                                                 \
                       old, new, old_str, new_str, old_map, new_map){

    # do we need to print a footer for a previous block?
    if (hunks){
        # pretty-print for terminals; add an underline to the last
        # word entry.
        q_underline()
        # mapping is purely a cosmetic addition, so it's handled on-demand
        old = block_old_cursor*4
        new = block_new_cursor*4
        old_map = map_an_address(old)
        new_map = map_an_address(new)
        old_str = sprintf("0x%08x",old)
        new_str = sprintf("0x%08x",new)
        # print address footer for prev block
        q(" ",color_bar)
        out_highlight(old_str,new_str,color_address_base,color_address_diff,1);
        q(" ----- ",color_bar)
        out_highlight(new_str,old_str,color_address_base,color_address_diff,1);
        q(" ", color_bar)
        q_line()
        # blank line
        q_line()
    }
    hunks++

    old = old_cursor*4
    new = new_cursor*4
    old_map = map_an_address(old)
    new_map = map_an_address(new)
    old_str = sprintf("0x%08x",old)
    new_str = sprintf("0x%08x",new)
    if (old == old_map && new == new_map){
        q(" ",color_bar_underline)
        out_highlight(old_str,new_str,color_address_base_underline,
                      color_address_diff_underline,1);
        q(" ----- ",color_bar_underline)
        out_highlight(new_str,old_str,color_address_base_underline,
                      color_address_diff_underline,1);
        q(" ", color_bar_underline)
        q_line()
    } else {
        q(" ")
        out_highlight(old_str,new_str,color_address_base,color_address_diff,1);
        q("       ")
        out_highlight(new_str,old_str,color_address_base,color_address_diff,1);
        q_line()

        old_str = sprintf("0x%08x",old_map)
        new_str = sprintf("0x%08x",new_map)

        q("[")
        out_highlight(old_str,new_str,color_address_base_underline,
                      color_address_diff_underline,1);
        q(" -", color_bar_underline)
        q("MAP", color_address_base_underline)
        q("- ", color_bar_underline)
        out_highlight(new_str,old_str,color_address_base_underline,
                      color_address_diff_underline,1);
        q("]")
        q_line()
    }
}

# Print one line of a diff block.  Takes two words formatted for
# display, optionally compares and applies highlights, adds the status
# indicator ('<' and/or '>') and prints.
function print_words(old_word, new_word,
                    c, ccolor) {
    if(old_word == new_word){
        q(sprintf(" %s     %s ", old_word, new_word), color_bytes_unchanged)
        q_line()
        old_cursor++
        new_cursor++
    } else {
        q(" ")
        out_highlight(old_word,new_word,attributes_off,color_bytes_oldchanged,0)
        c = "  !  "
        ccolor = color_bytes_changed
        if (old_word == "") {
            ccolor = color_bytes_newchanged
            c = "  >  "
        } else {
            old_cursor++
        }
        if (new_word == ""){
            ccolor = color_bytes_oldchanged
            c = "  <  "
        } else {
            new_cursor++
        }
        q(c,ccolor)
        out_highlight(new_word,old_word,attributes_off,color_bytes_newchanged,0);
        q(" ")
        q_line()
    }
    block_old_cursor = old_cursor
    block_new_cursor = new_cursor
}

function print_end(){
    q_line()
    q(" ----------- END ----------- ")
    q_line()
}

# Takes a line of input in the original packed/overlapping input
# formatting, and returns a 4-byte word formatted for printing.
function format_word(line){
    if(line == ""){
        return line
    } else {
        return sprintf("%2s %2s %2s %2s",
                       substr(line,2,2),
                       substr(line,4,2),
                       substr(line,6,2),
                       substr(line,8,2))
    }
}

# Toplevel for line-by-line output handling; manages context, address
# output and line formatting
function submit_line(old_line, new_line,
                     i, old_word, new_word){
    old_word = format_word(old_line)
    new_word = format_word(new_line)
    if(old_word == new_word){
        # push the line into context or print it?
        if(context_count<0){
            # running out post-context, so print
            print_words(old_word,old_word)
            context_count++
        } else {
            # already passed [context] identical lines, push to context queue
            for(i=context_count;i>0;i--) {
                context_word[i]=context_word[i-1]
            }
            context_word[0] = old_word
            if( context_count < context) {
                context_count++
            }else{
                # a line got pushed out of the context, update the
                # print address cursors
                old_cursor++
                new_cursor++
                new_block=1
            }
        }
    } else {
        # Do we need to print an address header?
        if (new_block) {
            # Yes. post-context has run out, or we're at/near
            # beginning of file.  Skip a line for visual break and
            # print an address header.
            print_address()
            new_block=0
        }
        # Print any pending pre-context
        for(i=context_count;i>0;i--) {
            print_words(context_word[i-1],context_word[i-1])
        }
        # Mark need for trailing context before starting a new address block
        context_count= -context
        # Flush/print as needed
        print_words(old_word, new_word)
    }
}

# Variant of the above for redacted output.
function redact_lines(num_lines,
                      i){
    if(num_lines > 0){
        # Do we need to print an address header?
        if (new_block) {
            # Yes. post-context has run out, or we're at/near
            # beginning of file.  Skip a line for visual break and
            # print an address header.
            print_address()
            new_block=0
        }
        # Print any pending pre-context
        for(i=context_count;i>0;i--) {
            print_words(context_word[i-1],context_word[i-1])
        }
        # Mark need for trailing context before starting a new address block
        context_count= -context
        # output redaction

        q(" ")
        q(".. .. .. .. <<< ",color_bytes_oldchanged)
        if(num_lines==1){
            q("1 line")
        }else{
            q(sprintf("%d lines", num_lines))
        }
        q_line()
        old_cursor+=num_lines
    }
}

# simple abs() function as there's no relaibly available built-in
function abs(v){
    if(v<0)v= -v
    return v
}

function push_old(line){
    old_line[old_count++]=line
    old_advance--
}

function push_new(line){
    new_line[new_count++]=line
    new_advance--
}

function remove_old(num,
                      j){
    # More concerned about being correct than
    # efficient right now, so doing it the simple way and just
    # shifting the line buffers.
    old_count -= num
    for(j=0; j<old_count; j++) old_line[j]=old_line[j+num]
}

function remove_new(num,
                      j){
    # More concerned about being correct than
    # efficient right now, so doing it the simple way and just
    # shifting the line buffers.
    new_count -= num
    for(j=0; j<new_count; j++) new_line[j]=new_line[j+num]
}

function remove_lines(num,
                      j){
    remove_old(num)
    remove_new(num)
}


function output_split(old_end, new_end,
                     i, j, old_pos, new_pos){
    # search exact word match up from bottom
    old_pos=old_end
    new_pos=new_end
    while(old_pos>0 && new_pos>0){
        if(substr(old_line[old_pos-1],2,8)!=            \
           substr(new_line[new_pos-1],2,8))break;
        old_pos--
        new_pos--
    }

    # When redacting input, we only worry about the mid lines of the
    # split.  Initial leading exact matches are stripped away by
    # forward match.  We shouldn't have any trailing exact matches at
    # the bottom of the split, because context is normally 0.  If
    # context is not 0 then that's a user override, so don't redact it.
    if (redact) {
        redact_lines(old_pos)
        for(j=0; j<new_pos; j++)
            submit_line("",new_line[j])
    } else {
        for(i=0; i<old_pos && i<new_pos; i++)
            submit_line(old_line[i], new_line[i])
        for(j=i; j<old_pos; j++)
            submit_line(old_line[j],"")
        for(j=i; j<new_pos; j++)
            submit_line("",new_line[j])
    }

    # now push the exact bottom matches
    while(old_pos<old_end && new_pos<new_end){
        submit_line(old_line[old_pos], new_line[new_pos])
        old_pos++
        new_pos++
    }
    # done
    remove_old(old_end)
    remove_new(new_end)
}

function match_forward(old_end, new_end,
                       i){
    # Excluding words from the initial exact natching through diff
    # will result in diff sections that begin with or consist
    # entirely of lines that actually do match.  Start by
    # submitting these exact matches (which will handle any
    # outputting needed).  Similarly, the recursive parsing breaks
    # up regions by exact match, and those exact matches will need
    # to be pushed here as well.
    for(i=0; i<old_end && i<new_end; i++){
        if(substr(old_line[i],2,8) != substr(new_line[i],2,8))break
        submit_line(old_line[i],new_line[i])
    }

    # Submitted lines need to be removed from the old and
    # new line lists.
    if (i>0) remove_lines(i)
    return i
}

function match_search(old_end, new_end, pos_return,
                      i, j){
    # search by increasing offset
    for (j=0; j<old_end || j<new_end; j++) {
        # common overlap loop
        for(i=0; i<new_end-j && i<old_end-j; i++){
            if(old_line[i] == new_line[i+j]) {
                pos_return["old"] = i
                pos_return["new"] = i+j
                pos_return["off"] = -j
                return
            }
            if(old_line[i+j] == new_line[i]) {
                pos_return["old"] = i+j
                pos_return["new"] = i
                pos_return["off"] = j
                return
            }
        }
        # more negative offset to search?
        while(i<new_end-j && i<old_end){
            if(old_line[i] == new_line[i+j]){
                pos_return["old"] = i
                pos_return["new"] = i+j
                pos_return["off"] = -j
                return
            }
            i++
        }
        # more positive offset to search?
        while(i<old_end-j && i<new_end){
            if(old_line[i+j] == new_line[i]){
                pos_return["old"] = i+j
                pos_return["new"] = i
                pos_return["off"] = j
                return
            }
            i++
        }
    }
    pos_return["old"] = old_end
    pos_return["new"] = new_end
    pos_return["off"] = old_end - new_end
}

function trim_for_subsearch(old_end, new_end, len,
                                   i){
    for(i=0; i<old_end; i++) old_line[i] = substr(old_line[i],1,len)
    for(i=0; i<new_end; i++) new_line[i] = substr(new_line[i],1,len)
}

function set_exclusions(old_end,
                        i){
    for(i=0; i<old_end; i++)
        old_line[i]=gensub(/(w)(00000000|ffffffff)/,"x\\2","g",old_line[i])
}


function clear_exclusions(old_end,
                          i){
    for(i=0; i<old_end; i++) gsub(/x/,"w",old_line[i])
}

function weak_split(old_end, new_end, threshold,
                    i, j, pos){
    if(threshold < match_words_min){
        clear_exclusions(old_end)
        output_split(old_end, new_end)
    }else{
        # Rather than complicating match with substr, perform it up front.
        trim_for_subsearch(old_end, new_end, threshold*9)

        while (new_end>0 || old_end>0) {
            i = match_forward(old_end, new_end)
            # update our own local subset end count
            old_end -= i
            new_end -= i
            # Do nothing further if that was the whole section.
            if(old_end==0 && new_end==0) break;

            # Look forward for exact matches; we split diff parsing at
            # that point.
            match_search(old_end, new_end, pos)

            # recurse, match or no.
            weak_split(pos["old"], pos["new"], threshold-1)

            # The weak_split call will always consume the entire region
            # passed to it.
            old_end -= pos["old"]
            new_end -= pos["new"]
        }
    }
}

# Successively break up initial region into exact matches searched by
# increasing offset.
function strong_split(old_end, new_end,
                      i, j, pos){
    while (new_end>0 || old_end>0) {
        i = match_forward(old_end, new_end)
        # update our own local subset end count
        old_end -= i
        new_end -= i
        # Do nothing further if that was the whole section.
        if(old_end==0 && new_end==0) break

        # Look forward for exact matches; we split diff parsing at
        # that point.
        match_search(old_end, new_end, pos)

        # If no exact matches, our region is not bookmarked by
        # initial matches, and so we don't have enough information
        # to make a good submatch.  Return.
        if(pos["old"] == old_end) break

        # if no currently active match horizon point, set it
        if(!advance_active){
            advance_active = 1
            old_advance = horizon
            new_advance = horizon
        }
        if(old_advance>0 || new_advance>0) return
        old_advance = 0
        new_advance = 0
        advance_active = 0

        # Check the buffered horizon against the offset.  We want
        # sufficient lookahead to make strong, low-offset matches
        # before doing lots of subdivision.  Thus we want to avoid
        # making immediate high-offset matches that would prevent
        # better low-offset matches in the future.

        # Heuristic is to make sure that there's sufficient buffer
        # that the matching positions from above would still land in
        # the existing the buffer if the offset sign is flipped.

        if(!diff_eof){
            new_advance = pos["old"] + horizon - new_end + pos["off"]*2
            old_advance = pos["new"] + horizon - old_end - pos["off"]*2
            if(new_advance > 0 || old_advance > 0){
                advance_active = 1
                return
            }
        }

        # Recurse to subdivide
        set_exclusions(old_end)
        weak_split(pos["old"], pos["new"], match_words_max-1)

        # Upon returning, we've parsed, output, and removed the
        # regions that previously stretched from [0 .. old_pos)
        # and [0 .. newpos). Update our own subset and iterate.
        old_end -= pos["old"]
        new_end -= pos["new"]
    }
}

function list_map_error(i, j,
                        k, str){
    err("       Requested mapping ranges:")
    for(k=0; k < address_maps; k++) {
        if (k+1 < address_maps) {
            str = sprintf("       %d) src: [0x%08x..0x%08x) -> "        \
                          "dst [0x%08x..0x%08x)",k,
                          address_map_src[k],
                          address_map_src[k+1],
                          address_map_dst[k],
                          address_map_dst[k] +                          \
                          address_map_src[k+1] - address_map_src[k])
        } else {
            str = sprintf("       %d) src: [0x%08x..   EOF    ] -> "    \
                          "dst [0x%08x..   EOF    ]",k,
                          address_map_src[k],
                          address_map_dst[k])
        }
        if (k==i || k==j) {
            str=str" <<<"
        }
        err(str)
    }
    err("")
}

function sanity_check_maps(                                             \
                           i, j, k, lenA, startA, endA, len, start, end){
    for (i=0; i < address_maps-1; i++) {
        lenA = address_map_src[i+1] - address_map_src[i]
        startA = address_map_dst[i]
        endA   = address_map_dst[i] + lenA
        for (j=i+1; j < address_maps; j++) {
            if (j+1 < address_maps) {
                len = address_map_src[j+1] - address_map_src[j]
                start = address_map_dst[j]
                end   = address_map_dst[j] + len
                if (start < startA) start = startA
                if (end > endA) end = endA
                if (start < end) {
                    err(sprintf("ERROR: Mapped destination address"     \
                                " conflict from 0x%08x to 0x%08x",
                                start, end))
                    list_map_error(i,j)
                    exit(1)
                }
            } else {
                start = address_map_dst[j]
                end = start + 1
                if (start < startA) start = startA
                if (end > endA) end = endA
                if (start < end) {
                    err(sprintf("ERROR: Mapped destination address"     \
                                " conflict beginning at 0x%08x",
                                start))
                    list_map_error(i,j)
                    exit(1)
                }
                if (start < endA) {
                    err("ERROR: Possible destination address"           \
                        " conflict depending on length of input.")
                    err(sprintf("       Final mapping destination may"  \
                                " extend into mapping %d.",i))
                    list_map_error(i,j)
                    exit(1)
                }
            }
        }
    }
}

# Internally, address mapping regions are simple src/dest
# pairs. Regions are ordered and each region stretches to the
# next so that there are no holes.
function add_map(dst, src, len,
                 i, j, k, src_prev, dst_prev){
    if (address_maps == 0) {
        address_map_src[0] = 0
        address_map_dst[0] = 0
        address_maps = 1;
    }
    dst = strtonum(dst)
    src = strtonum(src)
    # find insertion point for start of map
    for(i=0; i < address_maps; i++) {
        if(address_map_src[i] >= src) break
    }
    if(len == ""){
        # unbounded address map; add one entry from
        # src/dest to end of file, replacing any later entries
        address_map_src[i] = src
        address_map_dst[i] = dst
        address_maps = i+1;
    } else {
        len = strtonum(len)
        # bounded address map; add two entries, one that enters the
        # map and one that exits it, potentially to some previously
        # specified map that is only being partially replaced.

        # find where this map ends.  loop below saves mapping entry
        # we're cutting/replacing.
        src_prev = 0
        dst_prev = 0
        for(j=i; j < address_maps; j++) {
            if(address_map_src[j] > src+len) break
            src_prev = address_map_src[j];
            dst_prev = address_map_dst[j];
        }
        # we'll insert two entries and delete i through j exclusive;
        # expand/contract list past i as needed
        if(2 > j-i) {
            # expand
            for(k=address_maps-1; k>=i; k--){
                address_map_src[k+2-j+i] = address_map_src[k];
                address_map_dst[k+2-j+i] = address_map_dst[k];
            }
        } else if (2 < j-i) {
            #contract
            for(k=i+2; k<address_maps; k++){
                address_map_src[k] = address_map_src[k+j-i-2];
                address_map_dst[k] = address_map_dst[k+j-i-2];
            }
        }
        address_maps += 2-j+i
        address_map_src[i+1] = src + len
        address_map_dst[i+1] = (src + len - src_prev) + dst_prev
        address_map_src[i] = src
        address_map_dst[i] = dst
    }
}

function setup_color() {
    # fetch terminal info if we can
    if(INFOCMP){
        RS="^$"
        if ((cmd = INFOCMP" -0") | getline) {
            term = $0
            close(cmd)
        }
        RS="\n"
    }
    if (term ~ /colors/) {
        # is underline available?
        # is invisible mode available?
        if (term ~ /smul=/ && term ~ /invis=/) {
            # Invis means we can hide the '---' separators, so make
            # things prettier with an underline.
            attribute_underline = ";4"
            color_bar = "\033[0;8m"
            color_bar_underline = "\033[0;8;4m"
            color_address_base = "\033[0m"
            color_address_base_underline = "\033[0;4m"
            # is bold or rev available?
            if (term ~ /bold=/) {
                color_address_diff = "\033[0;1m"
                color_address_diff_underline = "\033[0;1;4m"
            } else if (term ~ /rev=/) {
                color_address_diff = "\033[0;7m"
                color_address_diff_underline = "\033[0;7;4m"
            } else {
                color_address_diff = "\033[0m"
                color_address_diff_underline = "\033[0;4m"
            }
        }else{
            # can't hide the ---, so don't use underlines.
            attribute_underline = ""
            color_bar = "\033[0m"
            color_bar_underline = "\033[0m"
            color_address_base = "\033[0m"
            color_address_base_underline = "\033[0m"
            # is bold or rev available?
            if (term ~ /bold=/) {
                color_address_diff = "\033[0;1m"
                color_address_diff_underline = "\033[0;1m"
            } else if (term ~ /rev=/) {
                color_address_diff = "\033[0;7m"
                color_address_diff_underline = "\033[0;7m"
            } else {
                color_address_diff = "\033[0m"
                color_address_diff_underline = "\033[0m"
            }
        }
        # is dim available?
        if (term ~ /dim=/) {
            color_address_deemph = "\033[0;2m"
            color_bytes_unchanged = "\033[0;2m"
        }else{
            color_address_deemph = "\033[0m"
            color_bytes_unchanged = "\033[0m"
        }
        # can we bold bright color changes?
        if (term ~ /bold=/) {
            color_bytes_oldchanged = "\033[0;31;1m"
            color_bytes_newchanged = "\033[0;32;1m"
            color_bytes_changed = "\033[0;1m"
        }else{
            color_bytes_oldchanged = "\033[0;31m"
            color_bytes_newchanged = "\033[0;32m"
            color_bytes_changed = "\033[0m"
        }
        attributes_off = "\033[0m"
    }
}

function disable_color(){
    color_address_base=""
    color_address_diff=""
    color_address_deemph=""
    color_bytes_unchanged=""
    color_bytes_oldchanged=""
    color_bytes_newchanged=""
    color_bytes_changed=""
    color_bar=""
    color_bar_underline=""
    attribute_underline = ""
    attributes_off=""
}

function stdout_usage(\
                      save_dev){
    save_dev=err_dev
    err_dev="/dev/stdout"
    usage()
    err_dev=save_dev
}

function usage(){
    err("")
    err("diff32 : A 'diff'-style comparison tool for raw 32 bit binaries")
    err("")
    err("USAGE  : diff32 [OPTIONS] fileA.bin fileB.bin")
    err("")
    err("OPTIONS:")
    err("")
    err("  -c, --context=NUM")
    err("")
    err("     Include NUM lines of copied context before and after changes.")
    err("     Minimum value is 0, maximum is 16.  Default is 3.")
    err("")
    err("  -d, --minimal")
    err("")
    err("     Try hard to find a smaller set of changes.")
    err("")
    err("  -h, --help")
    err("")
    err("     Output this help message and exit.")
    err("")
    err("  -l, --minimum-match-length=NUM")
    err("")
    err("     Sets the minimum length in words of a match when performing")
    err("     subdivision of large regions.  NUM may be 1 through 32 (default")
    err("     is 2 lines/words) and must be less than or equal to the initial")
    err("     match length.")
    err("")
    err("  -L, --initial-match-length=NUM")
    err("")
    err("     Sets the required match length in words when doing initial")
    err("     matching of large regions. NUM may be 1 through 32 (default")
    err("     is 8 lines/words) and must be greater than or equal to the")
    err("     minimum match length.")
    err("")
    err("  -m, --map=DESTINATION[,SOURCE[,LENGTH]]")
    err("")
    err("     Map displayed input byte range of LENGTH bytes starting at")
    err("     SOURCE byte offset to the range beginning at DESTINATION.  -m")
    err("     only affects displayed addresses, not match or output order.")
    err("     Omitting LENGTH extends range to the end of the file.  Omitting")
    err("     both SOURCE and LENGTH maps the entire input. More than one")
    err("     range may be specified. Later overlapping input ranges override")
    err("     earlier ranges. Final destination ranges may not overlap. Values")
    err("     may be decimal, octal (leading 0) or hexadecimal (leading 0x).")
    err("")
    err("  -n, --no-pager")
    err("")
    err("  -p, --pager")
    err("")
    err("  -r, --redact-original")
    err("")
    err("     Redact fileA's words from the diff32 output by emitting changes")
    err("     as block deletions from fileA marked '.. .. .. .. <<<', followed")
    err("     by insertions from fileB. Context is set to zero, but may be over-")
    err("     ridden by following with -c LINES.  Redaction is intended to")
    err("     minimize the amount of information from fileA included in output.")
    err("")
    err("  -s, --swap-endian")
    err("")
    err("     diff32 normally presents bytes in as-read order. -s instructs")
    err("     diff32 to swap the order it prints bytes on each line. -s has")
    err("     no effect on matching as matching is endian-agnostic.")
    err("")
    err("  -v, --version")
    err("")
    err("     Output version and exit.")
    err("")
    err("  -z, --extend-horizon=NUM")
    err("")
    err("     Add NUM additional words to the computed lookahead horizon when")
    err("     searching for initial matches with the lowest possible offsets.")
    err("     NUM may be between zero (disabling lookahead) and 4096. Higher")
    err("     values may produce better output at the cost of greatly increased")
    err("     computation time.  The default value is 32.")
    err("")
    err("  --color")
    err("")
    err("     Colorize the output.  Default behavior when using a pager.")
    err("")
    err("  --no-color")
    err("")
    err("     Do not colorize the output.")
    err("")
    err("DETAILS:")
    err("")
    err("     diff32 is a gawk script that wraps the standard diff utility")
    err("     to produce a human-readable side-by-side text summary of")
    err("     differences between two raw 32-bit binary files. diff32 ")
    err("     searches for changes, insertions, and deletions.")
    err("")
    err("EXAMPLE:")
    err("")
    err("  diff32 mips_binary1.bin mips_binary2.bin")
    err("")
    err("     Produce a colorized summary of the differences in binary files")
    err("     mips_binary1.bin and mips_binary2.bin, presented on the terminal")
    err("     one page at a time using the 'less' utility. The -d option to")
    err("     diff32 requests extra time be spent to minimize the change")
    err("     set. The -R option instructs less to allow ANSI color codes.")
    err("")
    err("AUTHOR:")
    err("")
    err("     Written by Monty Montgomery <monty@xiph.org>")
    err("     This is free software: you are free to change and redistribute")
    err("     it.  There is NO WARRANTY, to the extent permitted by law.")
    err("")
    err("SEE ALSO:")
    err("")
    err("  diff(1), cmp(1), xdelta(1), gawk(1)")
    err("")
}

function version () {
    q_line()
    q("diff32 version 0.0.3")
    q_line()
    if ((cmd = "/usr/bin/gawk --version 2>/dev/null") | getline) {
        q($0)
        close(cmd)
        q_line()
    }
    if ((cmd = DIFF" --version 2>/dev/null") | getline) {
        q($0)
        close(cmd)
        q_line()
    }
    if ((cmd = LESS" --version 2>/dev/null") | getline) {
        q($0)
        close(cmd)
        q_line()
    }
    if ((cmd = INFOCMP" -V 2>/dev/null") | getline) {
        q($0)
        close(cmd)
        q_line()
    }
    q_line()
}

function opterr(msg){
    err("")
    err("diff32: "msg"")
    err("        See man page or diff32 --help for more information.")
    err("")
    close("/dev/stdout")
    exit(1)
}

function getopts(argc, argv,
                 i, j, options_done, options, argument, pos){
    options_done = 0;
    for(i=1; i<argc; i++){
        option = ""
        delete argument
        if (!options_done){
            if (argv[i] == "--") {
                options_done = 1
            } else {
                if (substr(argv[i],1,2) == "--"){
                    pos = index(argv[i],"=")
                    if (pos>0) {
                        option = substr(argv[i],3,pos-3)
                        split(substr(argv[i],pos+1),argument,",")
                    } else {
                        option = substr(argv[i],3)
                    }
                } else if (substr(argv[i],1,1) == "-"){
                    if(length(argv[i])>2){
                        opterr("Error parsing command line argument.")
                    }
                    option = substr(argv[i],2)
                    split(argv[i+1],argument,",")
                } else {
                    if (fileA == "") {
                        fileA = argv[i]
                        continue
                    } else if (fileB =="") {
                        fileB = argv[i]
                        continue
                    } else {
                        opterr("Too many files specified on command line.")
                    }
                }
                if (option == "c" || option=="l" || option=="L" || option== "m" ||
                    option == "z"){
                    i++ # advance past argument
                }
                if (option == "c" || option == "context"){
                    if (argument[1] == "" || argument[2] != "") {
                        opterr("Context takes a single argument.")
                    }
                    context = strtonum(argument[1]);
                    if(context < 0 || context > 16){
                        opterr("Context argument must be in the range 0..16.")
                    }
                } else if (option == "d" || option == "minimal") {
                    minimal = "-d "
                } else if (option == "r" || option == "redact-original") {
                    redact = 1
                    context = 0
                } else if (option == "l" || option == "minimum-match-length") {
                    if (argument[1] == "" || argument[2] != "") {
                        opterr("Minimum match length takes a single argument.")
                    }
                    match_words_min = strtonum(argument[1]);
                    if(match_words_min < 1 || match_words_min>32){
                        opterr("Minimum match length must be in the range 1..32.")
                    }
                } else if (option == "L" || option == "initial-match-length") {
                    if (argument[1] == "" || argument[2] != "") {
                        opterr("Initial match length takes a single argument.")
                    }
                    match_words_max = strtonum(argument[1]);
                    if(match_words_max < 1 || match_words_max>32){
                        opterr("Initial match length must be in the range 1..32.")
                    }
                } else if (option == "h" || option == "help") {
                    stdout_usage()
                    exit(0)
                } else if (option == "m" || option == "map") {
                    if (argument[1] == "" || argument[4] != "") {
                        opterr("Map option takes one to three comma-separated arguments.")
                    }
                    add_map(argument[1],argument[2],argument[3])
                } else if (option == "n" || option == "no-pager" ||
                           option == "p" || option == "pager") {
                    # dummy; handled by the shell wrapper
                } else if (option == "s" || option == "swap-endian") {
                    swap = 1
                } else if (option == "v" || option == "version") {
                    version()
                    exit(0)
                } else if (option == "z" || option == "extend-horizon"){
                    if (argument[1] == "" || argument[2] != "") {
                        opterr("Horizon option takes a single argument.")
                    }
                    horizon = strtonum(argument[1]);
                    if(horizon < 0 || horizon > 4096){
                        opterr("Horizon argument must be in the range 0..4096.")
                    }
                } else if (option == "color") {
                    setup_color()
                } else if (option == "no-color") {
                    disable_color()
                } else {
                    opterr("Unknown arguemnt on command line.")
                }
            }
        } else {
            if (fileA == "") {
                fileA = argv[i]
            } else if (fileB =="") {
                fileB = argv[i]
            } else {
                opterr("Too many files specified on command line.")
            }
        }
    }

    if(fileA == "" || fileB == ""){
        opterr("Missing input file(s).")
    }

    if(match_words_min>match_words_max){
        opterr("Minimum match length must be less than or equal to initial match length.")
    }
    sanity_check_maps()
}

function output_maps(\
                     k){
    for(k=0; k < address_maps; k++) {
        q(sprintf("MAP: 0x%08x -> 0x%08x",
                    address_map_src[k],
                    address_map_dst[k]))
        q_line()
    }
    if(address_maps) q_line()
}

function find_util(path, envvar, report,
                   cmd){
    if(ENVIRON[envvar])path = ENVIRON[envvar]
    cmd = "command -v "path
    cmd|getline
    close(cmd)
    if(!$0 && report) err("diff32: Can't find '"path"' utility in the path.")
    return $0
}

BEGIN {
    # arguments
    context = 3
    minimal = ""
    swap = 0
    redact = 0
    match_words_min = 2
    match_words_max = 8
    horizon = 32

    # global state variables
    old_cursor=0
    new_cursor=0
    old_count=0
    new_count=0
    old_advance=0
    new_advance=0
    advance_active=0
    diff_eof=0
    context_count=0
    new_block=1
    hunks=0
    address_maps=0
    err_dev="/dev/stderr"

    DIFF = find_util("diff", "DIFFPROG", 1)
    LESS = find_util("less", "PAGER", 1)
    INFOCMP = find_util("infocmp", "INFOCMP", 0)
    getopts(ARGC, ARGV)

    # Convert binary input to undecorated hexadecimal ASCII.
    # This outputs a line per word, however each line consists of the
    # current word and the previous match_words_max-1 words as well.
    # This way we match on multiple words but with granularity.
    textify_cmd="LC_ALL=C /usr/bin/gawk '                               \
        BEGIN {\n                                                       \
            BINMODE = 3\n                                               \
            RS = \"[\\0-\\xff]{4}\"\n                                   \
            for(i=0;i<256;i++){\n                                       \
                f=sprintf(\"%c\",i)\n                                   \
                t=sprintf(\"%02x\",i)\n                                 \
                tohex[f]=t\n                                            \
            }\n                                                         \
        }\n                                                             \
        {\n                                                             \
            word = \"\"tohex[substr(RT,1,1)]\n                          \
            for(i=2;i<=8;i++) word = word\"\"tohex[substr(RT,i,1)]\n    \
            line = \"w\"word\"\"substr(line,1,"match_words_max"*9-9)\n  \
            print line\n                                                \
        }'"
    diff_cmd=DIFF" "                                                    \
        "--old-line-format=$'< %l\n' "                                  \
        "--new-line-format=$'> %l\n' "                                  \
        "--unchanged-line-format=$'= %l\n' "                            \
        "-- "                                                           \
        "<("textify_cmd" \""fileA"\") "                                 \
        "<("textify_cmd" \""fileB"\") "
    output_maps()
    q("")
    while(!ERRNO && (diff_cmd | getline) > 0){
        line = $2
        if ($1=="="){
            push_old(line)
            push_new(line)
            strong_split(old_count, new_count)
        } else if ($1=="<") {
            push_old(line)
        } else if ($1==">") {
            push_new(line)
        }
    }
    diff_eof = 1
    # flush each stage of the diff handling pipeline
    strong_split(old_count, new_count)
    output_split(old_count, new_count)
    print_end()
    close(diff_cmd)
    close("/dev/stdout")
}

############################ diff32 gawk script ends ############################
#EOF
############################ back to the bash wrapper ###########################

_interrupt() {
  # Immediate kill 0 won't do what we want; it kills us too.
  # The pager must fully exit first.
  kill -INT $pager_pid
  wait $pager_pid
  # now kill 0 will do what we want
  kill -TERM 0
}

# default pager utility and options if not locally set
if [ -z "${PAGER}" ]; then
  export PAGER="less -R -K -M -X -F"
fi

# default diff utility and options if not locally set
if [ -z "${DIFFPROG}" ]; then
  export DIFFPROG="diff"
fi

# Test for interactive terminal and pager executable;
# if both present, default to using the configured pager.
[[ ! ( -t 1 && -x $(command -v $PAGER)) ]]
use_pager=$?

# Allow user to override default pager use.
# Scan arguments without clobbering them.
args=( "$@" )
while test $# -gt 0
do
    case "$1" in
        -p|--pager)
          use_pager=1
            ;;
        -n|--no-pager|-v|--version|-h|--help)
          use_pager=0
            ;;
    esac
    shift
done

if [ $use_pager == 1 ]; then
  ####################### pager case ############################
  # exec script, get output fd and pid.
  exec {diff32_fd}< <(gawk -f - -- "--color" "${args[@]}" <&$script_fd) ; script_pid=$!
  # Trap interrupts before starting pager.
  trap _interrupt INT
  # Connect pager to script, get pager fd.
  $PAGER $PAGER_ARGS <&$diff32_fd & pager_pid=$!
  # Gate on the pager.
  wait $pager_pid
  # Done. Issue a kill to clean up children if pager quit before
  # diffing completed, and script didn't notice for some reason
  # (it should have, but might be stuck for some other reason).
  trap '' INT
  kill -INT 0
else
  ##################### non-pager case ##########################
  # run script.
  gawk -f - -- "${args[@]}" <&$script_fd
fi
