#!/usr/bin/awk -E

# helper function to print the input to_print, optionally colorizing
# the nibbles that match the comparison input to_compare using
# the escape sequence 'off', and the nibbles that do not match with 'on'.
# 'lock' is nonzero if a color change to 'on' should persist for the
# rest of the string regardless of match; this is used to highlight
# address differences.
function print_highlight(to_print, to_compare, off, on, lock, redact,
                         current, a, b, i){
    current = off
    for(i=1; i<=length(to_print); i++){
        a = substr(to_print,i,1)
        b = substr(to_compare,i,1)
        if (a != b){
            if (current == off) {
                if (lock) {
                    current = lock
                }else{
                    current = on
                }
                printf on
            }
        } else {
            if (current == on) {
                current = off;
                printf off
            }
        }
        if(redact && a!=" "){
            printf "."
        } else {
            printf a
        }
    }
    if (current != off) printf off
}

function map_an_address(addr,
                        i){
    for (i=0; i<address_maps; i++) {
        if (address_map_src[i] <= addr) {
            addr = address_map_dst[i] + addr - address_map_src[i]
            break
        }
    }
    return addr
}

# print an address header at the beginning of a new block of differences.
function print_address(old, new,
                       old_str, new_str, old_map, new_map, bar, base, diff){

    # mapping is purely a cosmetic addition, so it's handled on-demand here
    old_map = map_an_address(old)
    new_map = map_an_address(new)
    old_str = sprintf("0x%08x",old)
    new_str = sprintf("0x%08x",new)

    bar = " "
    if (old == old_map && new == new_map){
        if(!color_address_base) bar = "_"
        base = color_address_base
        diff = color_address_diff
    } else {
        base = color_unchanged
        diff = color_unchanged
    }
    printf bar""base
    print_highlight(old_str,new_str,base,diff,1,0);
    printf bar""bar""bar""bar""bar""bar""bar
    print_highlight(new_str,old_str,base,diff,1,0);
    printf color_off""bar"\n"

    if (old != old_map || new != new_map){
        old_str = sprintf("0x%08x",old_map)
        new_str = sprintf("0x%08x",new_map)
        base = color_address_base
        diff = color_address_diff
        if(!color_address_base) bar = "_"

        printf "["base
        print_highlight(old_str,new_str,base,diff,1,0);
        printf bar""bar"MAP"bar""bar
        print_highlight(new_str,old_str,base,diff,1,0);
        printf color_off"]\n"
    }
}

# print one line of a diff block
function print_line(old, c, new) {
    if(c == " "){
        printf color_unchanged" %s  %s  %s"color_off, old, c, new
    }else{
        printf " "
        print_highlight(old,new,color_off,color_bytes_old,0,embargo);
        if (c == "<") {
            printf color_bytes_old
        } else if (c == ">" ){
            printf color_bytes_new
    } else if (c == "!" ){
            printf color_bytes_changed
        }
        printf "  %s  "color_off, c
        print_highlight(new,old,color_off,color_bytes_new,0,0);
    }
    printf "\n"
}

# simple abs() function as there's no relaibly available built-in
function abs(v){
    if(v<0)v= -v
    return v
}

# Compare the binary strings A and B, each consisting of 4 octets
# separated by spaces, each octet containing the characters '1' or
# '0', and produce a similarity score.  The scoring works 8 bits at a
# time, partly to avoid any issues with endianness.  It counts runs of
# matching characters, weights each run, and sums the weighted run
# values into a raw score. Finally, we adjust this score, reducing it
# according to a basic entropy measure (ie, if our input is nearly all
# zeros or nearly all ones, there's probably not much actual entropy
# there.  Think of long 'empty' runs of 0x00000000 or 0xffffffff in
# typical binaries; fuzzy matching needs to mostly disregard them).
function score_line(A, B,
                    i, j, ones, run_total, run, Ab, Bb, score){
    ones = 0
    run_total = 0

    for (j=1; j <=35; j+=9) {
        run = 1
        for (i=0; i<8; i++) {
            Ab = substr(A,i+j,1)
            Bb = substr(B,i+j,1)
            if (Ab == "0") {
                if(Bb == "0") {
                    run++
                } else {
                    ones++
                    run_total += run_weight[run]
                    run = 1
                }
            } else {
                ones++
                if(Bb == "1") {
                    ones++
                    run++
                } else {
                    run_total += run_weight[run]
                    run = 1
                }
            }
        }
        run_total += run_weight[run]
    }
    score = run_total - entropy_weight[abs(32-ones)+1]
    if(score < 0) score = 0
    return score
}

# Computes a fuzzy match score for the currently loaded old/new lines,
# overlapped by the passed in offset.
function compute_match(offset,
                       i, score, value, max, start, count) {
    score = 0
    max = 0

    # Deemphasis reduces short match scores relative to long matches,
    # as their smaller samples size makes strong high scores
    # relatively more likely.
    count = small_match_derate

    if(offset < 0) {
        start = 0
    } else {
        start = offset;
    }
    for(i=start; i<old_count && i<new_count+offset; i++){
        value = score_line(old_line[i],new_line[i-offset])
        if (value>max) max = value
        score += value
        count++
    }
    if(count <= 0) return 0

    # Make score relative to match size.
    score /= count

    # Reject weak matches.  A 'weak match' is a maximum match score of
    # less than ~ 8 contiguous bits and an overall average score of
    # lewss than half that maximum.
    if (max < weighted_fuzzy || score < weighted_fuzzy/2)
        return -1

    # Weight toward the zero offset
    if(offset == 0) {
        score = zero_weight*(score+zero_offset)
    }
    return score
}

# overlap offset is the amount by which the new_lines block is offset
# relative to the old_lines block.  Negative indicates the new_lines
# start first, positive indicates new_lines beginning follows
# old_lines beginning.
function overlap_stored_diff(\
    i, best_overlap, best_score, score) {
    # Diff hands all changes to us as a set of < lines and then >
    # lines.  Diff does not do fuzzy matching, and we probably don't
    # want to mangle together a diff incant that tries. We look for
    # overlaps using partial matches ourselves here.

    # always present isolated single-line changes are overlaps.
    if(old_count == 1 && new_count == 1) return 0

    # If we have only one set of changes (pure deletion or pure insertion)
    # there's no point in checking further.
    if(old_count == 0 || new_count == 0) return 0

    # Don't try to overlap large changes; the search will take too
    # long, and it's not clear to me we're likely to find a good match
    # anyway.  If this guess proves wrong, we can try harder in the future.
    if(old_count > 256 && new_count > 256) return old_count

    # Search for overlap by comparing each offset.
    # Choose the high score as our match, break ties by closest to zero.
    best_overlap = 0
    best_score = compute_match(0)

    for (i=1; i<=old_count || i<=new_count; i++) {
        if (i<=old_count) {
            score = compute_match(i)
            if(score > best_score) {
                best_overlap = i;
                best_score = score;
            }
        }
        if (i<=new_count) {
            score = compute_match(-i)
            if(score > best_score) {
                best_overlap = -i;
                best_score = score;
            }
        }
    }

    # If we found no strong matches, best score will be -1.  In this
    # case, return a non-overlap, that is, deletions followed by
    # insertions.
    if (best_score == -1) return old_count

    return best_overlap
}

# Input from od is hexadecimal octets separated by spaces.  Output is
# binary octets separated by spaces. Input order is preserved (order
# of the octets themselves is irrelevant to the fuzzy matching).
function tobinary(hex_input_line,
                  i, ret) {
    ret=""
    for(i=1; i<=length(hex_input_line); i++){
        ret = ret""binary_nibbles[substr(hex_input_line,i,1)]
    }
    return ret
}

# map from internal binary strings back to space-separated hex
# octets for printing
function tohex(binary_input_line,
                  i, j, n0, n1, ret){
    ret = ""
    for(i=1; i+7<=length(binary_input_line); i+=9) {
        n0 = 0
        n1 = 0
        for(j=0; j<4; j++)
            n0 = (n0*2) + substr(binary_input_line,i+j,1)+0
        for(; j<8; j++)
            n1 = (n1*2) + substr(binary_input_line,i+j,1)+0
        if (i==1){
            ret = sprintf("%x%x",n0,n1)
        } else {
            if (swap) {
                ret = sprintf("%x%x %s",n0,n1,ret)
            } else {
                ret = sprintf("%s %x%x",ret,n0,n1)
            }
        }
    }
    return ret
}

function print_stored_diff(                                     \
    old_start, new_start, diff_start, overlap_offset, i, tmp) {
    old_start = old_cursor - old_count*4;
    new_start = new_cursor - new_count*4;

    if (context_count >= context || near_beginning) {
        # post-context has run out, or we're at/near beginning of file.
        # Skip a line for visual break and print an address header.
        if (!near_beginning) printf "\n"
        print_address(old_start, new_start)
        near_beginning=0
    }
    # print any pending pre-context
    for(i=context_count;i>0;i--) {
        print_line(context_line[i-1]," ",context_line[i-1])
    }

    # the actual differing lines
    if (fuzzy) {
        overlap_offset = overlap_stored_diff()
    } else {
        overlap_offset = old_count
    }
    if(overlap_offset < 0) {
        diff_start = overlap_offset;
    } else {
        diff_start = 0;
    }
    for(i=diff_start; i<old_count || i<new_count+overlap_offset; i++){
        if(i>=0 && i<old_count){
            if(i>=overlap_offset && i<new_count+overlap_offset){
                # Although I don't think diff will ever return any
                # matching lines in the diff segments, handle the
                # possibility.
                if(old_line[i] == new_line[i-overlap_offset]){
                    print_line(tohex(old_line[i]),
                               " ",
                               tohex(new_line[i-overlap_offset]))
                } else {
                    print_line(tohex(old_line[i]),
                               "!",
                               tohex(new_line[i-overlap_offset]))
                }
            } else {
                if(embargo){
                    if(i==0){
                        printf color_bytes_old" [%9s]  <\n"color_off,
                            sprintf("0x%x",old_count)
                    }
                }else{
                    print_line(tohex(old_line[i]),"<","           ")
                }
            }
        }else{
            print_line("           ",">",tohex(new_line[i-overlap_offset]))
        }
    }
    old_count=0
    new_count=0
    context_count= -context
}

function print_end(){
    printf "\n ----------- END ----------- \n"
}

function out(string){
    if (use_stderr) {
        print string | "cat 1>&2"
    } else {
        print string
    }
}

function stdout_usage(){
    save_stderr = use_stderr
    use_stderr = err
    usage()
    use_stderr = save_stderr
}

function usage(){
    out("")
    out("diff32 : A 'diff'-style comparison tool for raw 32 bit binaries")
    out("")
    out("USAGE  : diff32 [OPTIONS] fileA.bin fileB.bin")
    out("")
    out("OPTIONS:")
    out("")
    out("  -c, --context=NUM")
    out("")
    out("     Include NUM lines of copied context before and after changes.")
    out("     Minimum value is 0, maximum is 16.  Default is 3.")
    out("")
    out("  -d, --minimal")
    out("")
    out("     Try hard to find a smaller set of changes.")
    out("")
    out("  -e, --embargo-deletion")
    out("")
    out("     Emit deletions as placeholders indicating the number of words")
    out("     omitted from fileA. Emit line changes (ie, ! lines) with words")
    out("     from fileA obscured. Context is set to zero, but may be over-")
    out("     ridden by following with -c LINES.  Embargo is intended to")
    out("     minimize the amount of fileA included in output.")
    out("")
    out("  -f, --fuzzy=NUM")
    out("")
    out("     Adjust the matching threshold that diff32 uses to present two")
    out("     regions as overlapping/similar using '!', instead of deletions")
    out("     '<' followed by insertions '>'. Fuzzy matching is nonlinear, but")
    out("     the value roughly sets the minimum sequence of matching bits to")
    out("     consider two words a loose match.  Note that single-line")
    out("     changes are always presented as '!' regardless of match.")
    out("     Minimum value is 0, max is 32. Default is 16 (two 8-bit bytes).")
    out("")
    out("  -h, --help")
    out("")
    out("     Out(this help message and exit.")
    out("")
    out("  -m, --map=DESTINATION[,SOURCE[,LENGTH]]")
    out("")
    out("     Map displayed input byte range of LENGTH bytes starting at")
    out("     SOURCE byte offset to the range beginning at DESTINATION.  -m")
    out("     only affects displayed addresses, not match or output order.")
    out("     Omitting LENGTH extends range to the end of the file.  Omitting")
    out("     both SOURCE and LENGTH maps the entire input. More than one")
    out("     range may be specified. Later overlapping input ranges override")
    out("     earlier ranges. Final destination ranges may not overlap. Values")
    out("     may be decimal, octal (leading 0) or hexadecimal (leading 0x).")
    out("")
    out("  -n, --no-fuzzy")
    out("")
    out("     Do not perform 'fuzzy' overlap matching.  Presents output")
    out("     as deletions ('<') followed by insertions ('>') only, with no")
    out("     change ('!') lines (including no single-line changes).")
    out("")
    out("  -s, --swap-endian")
    out("")
    out("     diff32 normally presents bytes in as-read order. -s instructs")
    out("     diff32 to swap the order it prints bytes on each line. -s has")
    out("     no effect on matching as matching is endian-agnostic.")
    out("")
    out("  -v, --version")
    out("")
    out("     Out(version and exit.")
    out("")
    out("  --color")
    out("")
    out("     Colorize the output.")
    out("")
    out("DETAILS:")
    out("")
    out("     diff32 is an awk script wrapping the od and diff utilities")
    out("     that produces a human-readable side-by-side text summary of")
    out("     differences between two raw 32-bit binary files.")
    out("")
    out("     diff32 searches for insertions, deletions, and co-located")
    out("     changes. By default, it will also perform fuzzy matching to")
    out("     align regions of similar content.")
    out("")
    out("EXAMPLE:")
    out("")
    out("  diff32 -d --color mips_binary1.bin mips_binary2.bin | less -R")
    out("")
    out("     Produce a colorized summary of the differences in binary files")
    out("     mips_binary1.bin and mips_binary2.bin, presented on the terminal")
    out("     one page at a time using the 'less' utility. The -d option to")
    out("     diff32 requests extra time be spent to minimize the change")
    out("     set. The -R option instructs less to allow ANSI color codes.")
    out("")
    out("AUTHOR:")
    out("")
    out("     Written by Monty Montgomery <monty@xiph.org>")
    out("     This is free software: you are free to change and redistribute")
    out("     it.  There is NO WARRANTY, to the extent permitted by law.")
    out("")
    out("SEE ALSO:")
    out("")
    out("  od(1), diff(1), cmp(1), xdelta(1)")
    out("")
}

function version () {
    print ""
    print "diff32 version 0.0.2"
    if ("awk --version" | getline) {
        print $0
    }
    if ("diff --version" | getline) {
        print $0
    }
    if ("od --version" | getline) {
        print $0
    }
    print ""
}

function list_map_error(i, j,
                        k, str){
    printe("       Requested mapping ranges:")
    for(k=0; k < address_maps; k++) {
        if (k+1 < address_maps) {
            str = sprintf("       %d) src: [0x%08x..0x%08x) -> "        \
                          "dst [0x%08x..0x%08x)",k,
                          address_map_src[k],
                          address_map_src[k+1],
                          address_map_dst[k],
                          address_map_dst[k] +                          \
                          address_map_src[k+1] - address_map_src[k])
        } else {
            str = sprintf("       %d) src: [0x%08x..   EOF    ] -> "    \
                          "dst [0x%08x..   EOF    ]",k,
                          address_map_src[k],
                          address_map_dst[k])
        }
        if (k==i || k==j) {
            str=str" <<<"
        }
        printe(str)
    }
    printe("")
}

function sanity_check_maps(                                             \
                           i, j, k, lenA, startA, endA, len, start, end){
    for (i=0; i < address_maps-1; i++) {
        lenA = address_map_src[i+1] - address_map_src[i]
        startA = address_map_dst[i]
        endA   = address_map_dst[i] + lenA
        for (j=i+1; j < address_maps; j++) {
            if (j+1 < address_maps) {
                len = address_map_src[j+1] - address_map_src[j]
                start = address_map_dst[j]
                end   = address_map_dst[j] + len
                if (start < startA) start = startA
                if (end > endA) end = endA
                if (start < end) {
                    printe(sprintf("ERROR: Mapped destination address"  \
                                   " conflict from 0x%08x to 0x%08x",
                                   start, end))
                    list_map_error(i,j)
                    exit(1)
                }
            } else {
                start = address_map_dst[j]
                end = start + 1
                if (start < startA) start = startA
                if (end > endA) end = endA
                if (start < end) {
                    printe(sprintf("ERROR: Mapped destination address"  \
                                   " conflict beginning at 0x%08x",
                                   start))
                    list_map_error(i,j)
                    exit(1)
                }
                if (start < endA) {
                    printe("ERROR: Possible destination address"        \
                           " conflict depending on length of input.")
                    printe(sprintf("       Final mapping destination may" \
                                   " extend into mapping %d.",i))
                    list_map_error(i,j)
                    exit(1)
                }
            }
        }
    }
}

# Internally, address mapping regions are simple src/dest
# pairs. Regions are ordered and each region stretches to the
# next so that there are no holes.
function add_map(dst, src, len,
                 i, j, k, src_prev, dst_prev){
    if (address_maps == 0) {
        address_map_src[0] = 0
        address_map_dst[0] = 0
        address_maps = 1;
    }
    dst = strtonum(dst)
    src = strtonum(src)
    # find insertion point for start of map
    for(i=0; i < address_maps; i++) {
        if(address_map_src[i] >= src) break
    }
    if(len == ""){
        # unbounded address map; add one entry from
        # src/dest to end of file, replacing any later entries
        address_map_src[i] = src
        address_map_dst[i] = dst
        address_maps = i+1;
    } else {
        len = strtonum(len)
        # bounded address map; add two entries, one that enters the
        # map and one that exits it, potentially to some previously
        # specified map that is only being partially replaced.

        # find where this map ends.  loop below saves mapping entry
        # we're cutting/replacing.
        src_prev = 0
        dst_prev = 0
        for(j=i; j < address_maps; j++) {
            if(address_map_src[j] > src+len) break
            src_prev = address_map_src[j];
            dst_prev = address_map_dst[j];
        }
        # we'll insert two entries and delete i through j exclusive;
        # expand/contract list past i as needed
        if(2 > j-i) {
            # expand
            for(k=address_maps-1; k>=i; k--){
                address_map_src[k+2-j+i] = address_map_src[k];
                address_map_dst[k+2-j+i] = address_map_dst[k];
            }
        } else if (2 < j-i) {
            #contract
            for(k=i+2; k<address_maps; k++){
                address_map_src[k] = address_map_src[k+j-i-2];
                address_map_dst[k] = address_map_dst[k+j-i-2];
            }
        }
        address_maps += 2-j+i
        address_map_src[i+1] = src + len
        address_map_dst[i+1] = (src + len - src_prev) + dst_prev
        address_map_src[i] = src
        address_map_dst[i] = dst
    }
}

function getopts(argc, argv,
                 i, j, options_done, options, argument, pos){
    options_done = 0;
    for(i=1; i<argc; i++){
        option = ""
        delete argument
        if (!options_done){
            if (argv[i] == "--") {
                options_done = 1
            } else {
                if (substr(argv[i],1,2) == "--"){
                    pos = index(argv[i],"=")
                    if (pos>0) {
                        option = substr(argv[i],3,pos-3)
                        split(substr(argv[i],pos+1),argument,",")
                    } else {
                        option = substr(argv[i],3)
                    }
                } else if (substr(argv[i],1,1) == "-"){
                    if(length(argv[i])>2){
                        usage()
                        exit(1)
                    }
                    option = substr(argv[i],2)
                    split(argv[i+1],argument,",")
                } else {
                    if (fileA == "") {
                        fileA = argv[i]
                        continue
                    } else if (fileB =="") {
                        fileB = argv[i]
                        continue
                    } else {
                        usage()
                        exit(1)
                    }
                }
                if (option == "c" || option == "f" || option== "m"){
                    i++ # advance past argument
                }
                if (option == "c" || option == "context"){
                    if (argument[1] == "" || argument[2] != "") {
                        usage()
                        exit(1)
                    }
                    context = strtonum(argument[1]);
                    if(context < 0 || context > 16){
                        usage()
                        exit(1)
                    }
                } else if (option == "d" || option == "minimal") {
                    minimal = "-d "
                } else if (option == "e" || option == "embargo-deletion") {
                    embargo = 1
                    context = 0
                } else if (option == "f" || option == "fuzzy") {
                    if (argument[1] == "" || argument[2] != "") {
                        usage()
                        exit(1)
                    }
                    fuzzy_threshold = strtonum(argument[1]);
                    if(fuzzy_threshold < 0 || fuzzy_threshold>32){
                        usage()
                        exit(1)
                    }
                } else if (option == "h" || option == "help") {
                    stdout_usage()
                    exit(0)
                } else if (option == "m" || option == "map") {
                    if (argument[1] == "" || argument[4] != "") {
                        usage()
                        exit(1)
                    }
                    add_map(argument[1],argument[2],argument[3])
                } else if (option == "n" || option == "no-fuzzy") {
                    fuzzy = 0
                } else if (option == "s" || option == "swap-endian") {
                    swap = 1
                } else if (option == "v" || option == "version") {
                    version()
                    exit(0)
                } else if (option == "color") {
                    color = 1
                } else {
                    usage()
                    exit(1)
                }
            }
        } else {
            if (fileA == "") {
                fileA = argv[i]
            } else if (fileB =="") {
                fileB = argv[i]
            } else {
                usage()
                exit(1)
            }
        }
    }

    if(fileA == "" || fileB == ""){
        usage()
        exit(1)
    }
    sanity_check_maps()
}

function output_maps(\
                     k){
    for(k=0; k < address_maps; k++) {
        printf "MAP: 0x%08x -> 0x%08x\n",
            address_map_src[k],
            address_map_dst[k]
    }
    if(address_maps) print ""
}

BEGIN {
    context=3
    color=0
    minimal=""
    fuzzy_threshold=16
    fuzzy=1
    swap=0
    embargo=0
    # weight slightly toward zero offset
    zero_offset = 2
    zero_weight = 1.10
    small_match_derate = 1

    old_cursor=0
    new_cursor=0
    old_count=0
    new_count=0
    context_count=0
    near_beginning=1
    weighted_fuzzy=0
    address_maps=0
    use_stderr=1

    getopts(ARGC, ARGV)

    binary_nibbles[" "] = " "
    binary_nibbles["0"] = "0000"
    binary_nibbles["1"] = "0001"
    binary_nibbles["2"] = "0010"
    binary_nibbles["3"] = "0011"
    binary_nibbles["4"] = "0100"
    binary_nibbles["5"] = "0101"
    binary_nibbles["6"] = "0110"
    binary_nibbles["7"] = "0111"
    binary_nibbles["8"] = "1000"
    binary_nibbles["9"] = "1001"
    binary_nibbles["a"] = "1010"
    binary_nibbles["b"] = "1011"
    binary_nibbles["c"] = "1100"
    binary_nibbles["d"] = "1101"
    binary_nibbles["e"] = "1110"
    binary_nibbles["f"] = "1111"

    split("0 1 2 4 8 12 16 20 28 ",
          run_weight,
          " ")

    while (fuzzy_threshold > 8) {
        weighted_fuzzy += run_weight[9]
        fuzzy_threshold -= 8
    }
    weighted_fuzzy += run_weight[fuzzy_threshold+1]

    split("0 0 0 0 0 0 0 0 0 "                  \
          "0 0 0 0 0 0 1 2 "                    \
          "3 4 5 6 8 10 12 14 "                 \
          "16 20 24 28 32 50 74 112 ",
          entropy_weight,
          " ")

    if (color) {
        color_address_base = "\033[0;4m"
        color_address_diff = "\033[0;1;4m"
        color_unchanged = "\033[0;2m"
        color_bytes_old = "\033[0;31;1m"
        color_bytes_new = "\033[0;32;1m"
        color_bytes_changed = "\033[0;1m"
        color_off = "\033[0m"
    } else {
        color_address_base = ""
        color_address_diff = ""
        color_unchanged=""
        color_bytes_old=""
        color_bytes_new=""
        color_bytes_changed=""
        color_off=""
    }
    od_cmd="od -Anone -tx1 -w4 -v --"
    diff_cmd="diff "                                                    \
        minimal                                                         \
        "--old-line-format=$'< %l\n' "                                  \
        "--new-line-format=$'> %l\n' "                                  \
        "--unchanged-line-format=$'= %l\n' "                            \
        "-- "                                                           \
        "<("od_cmd" "fileA") "                                          \
        "<("od_cmd" "fileB") "                                          \

    output_maps()
    while(diff_cmd | getline){
        if ($1=="="){
            line = tobinary($2" "$3" "$4" "$5)
            if(new_count>0 || old_count>0) {
                print_stored_diff()
            }
            if(context_count<0){
                # running out post-context
                print_line(tohex(line), " ", tohex(line) )
            } else {
                # saving up pre-context
                for(i=context_count;i>0;i--) {
                    context_line[i]=context_line[i-1]
                }
                context_line[0] = tohex(line)
            }
            old_cursor+=4
            new_cursor+=4
            if( context_count < context) {
                context_count++
            }
        } else if ($1=="<") {
            line = tobinary($2" "$3" "$4" "$5)
            old_line[old_count++]=line
            old_cursor+=4
        } else if ($1==">") {
            line = tobinary($2" "$3" "$4" "$5)
            new_line[new_count++]=line
            new_cursor+=4
        }
    }
    if(new_count>0 || old_count>0) print_stored_diff()
    if(!near_beginning) print_end()
 }
